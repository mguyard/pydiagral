{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#documentation-pydiagral","title":"Documentation pydiagral","text":"<p>Welcome to the documentation for pydiagral, a Python library for interacting with the Diagral API.</p>"},{"location":"#about-pydiagral","title":"About pydiagral","text":"<p>pydiagral is an asynchronous Python interface for the Diagral alarm system. This library allows users to control and monitor their Diagral alarm system through the official API.</p> <p>[!CAUTION]</p> <p>Please note that the Diagral alarm system is a security system, and it may be preferable not to connect it to any automation platform for security reasons. In no event shall the developer of <code>pydiagral</code> library be held liable for any issues arising from the use of this <code>pydiagral</code> library. The user installs and uses this integration at their own risk and with full knowledge of the potential implications.</p>"},{"location":"#requirement","title":"Requirement","text":"<p>To use this library, which leverages the Diagral APIs, you must have a Diagral box (DIAG56AAX). This box connects your Diagral alarm system to the internet, enabling interaction with the alarm system via the API. You can find more information about the Diagral box here.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>The <code>DiagralAPI</code> class offers the following functionalities:</p> <ul> <li> <p>Authentication:</p> </li> <li> <p>Connect to the Diagral API with username and password</p> </li> <li>Manage access tokens and their expiration</li> <li> <p>Create, validate, and delete API keys</p> </li> <li> <p>System Configuration:</p> </li> <li> <p>Retrieve alarm configuration</p> </li> <li> <p>System Information:</p> </li> <li> <p>Obtain system details</p> </li> <li>Retrieve the current system status</li> <li>Manage webhooks</li> <li> <p>Manage anomalies</p> </li> <li> <p>System Interraction:</p> </li> <li>Activate or Desactivate system (partially or globally)</li> <li>Automatism actions</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To get started with pydiagral, follow these steps:</p> <ol> <li>Installation:</li> </ol> <p><code>bash    pip install pydiagral</code></p> <ol> <li>Example</li> </ol> <p>A modular and easy-to-use test script is available example_code.py to help you get started with the library.</p> <p>Simply create a <code>.env</code> file with the following content:</p> <pre><code>USERNAME=your_email@example.com\nPASSWORD=your_password\nSERIAL_ID=your_serial_id\nPIN_CODE=your_pin_code\nLOG_LEVEL=DEBUG\n</code></pre> <p>And run the example_code.py.</p> <p>TIP</p> <p>You can customize the actions performed by example_code.py by modifying the parameters in the code, as indicated by the <code>CUSTOMIZE THE TESTS</code> section title.</p>"},{"location":"#api-structure","title":"API Structure","text":"<p>For detailed API documentation, please refer to the following sections:</p> <ul> <li>API Reference: Comprehensive documentation of the DiagralAPI class and its methods</li> <li>Data Models: Description of the data structures used</li> <li>Exceptions: List of package exceptions</li> </ul>"},{"location":"#contribution","title":"Contribution","text":"<p>Contributions to pydiagral are welcome! Please check our contribution guidelines for more information on how to participate in the development of this library.</p>"},{"location":"#license","title":"License","text":"<p>pydiagral is distributed under the GPL-v3 License. See the LICENSE file for more details.</p>"},{"location":"api/","title":"DiagralAPI Reference","text":""},{"location":"api/#diagralapi-reference","title":"DiagralAPI Reference","text":""},{"location":"api/#pydiagral.api","title":"<code>pydiagral.api</code>","text":"<p>Module for interacting with the Diagral API.</p> <p>This module provides a DiagralAPI class that encapsulates all the functionality for communicating with the Diagral alarm system API, including authentication, retrieving system status, and controlling various aspects of the alarm system.</p>"},{"location":"api/#pydiagral.api.DiagralAPI","title":"<code>DiagralAPI</code>","text":"<p>Provide interface for interacting with the Diagral API.</p> <p>This class encapsulates all the functionality for communicating with the Diagral alarm system API, including authentication, retrieving system status, and controlling various aspects of the alarm system.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>class DiagralAPI:\n    \"\"\"Provide interface for interacting with the Diagral API.\n\n    This class encapsulates all the functionality for communicating with\n    the Diagral alarm system API, including authentication, retrieving\n    system status, and controlling various aspects of the alarm system.\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        serial_id: str,\n        apikey: str | None = None,\n        secret_key: str | None = None,\n        pincode: int | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the DiagralAPI instance.\n\n        Args:\n            username (str): The email address for Diagral API authentication.\n            password (str): The password for Diagral API authentication.\n            serial_id (str): The serial ID of the Diagral system.\n            apikey (str | None, optional): The API key for additional authentication. Defaults to None.\n            secret_key (str | None, optional): The secret key for additional authentication. Defaults to None.\n            pincode (int | None, optional): The PIN code for the Diagral system. Defaults to None.\n\n        Raises:\n            ConfigurationError: If any required field is empty or invalid.\n\n        \"\"\"\n        # Validate username as an email\n        if (\n            not username\n            or not isinstance(username, str)\n            or not self.__is_valid_email(username)\n        ):\n            raise ConfigurationError(\"username must be a valid non-empty email address\")\n        self.username: str = username\n\n        # Validate password\n        if not password or not isinstance(password, str):\n            raise ConfigurationError(\"password must be a non-empty string\")\n        self.__password: str = password\n\n        # Validate serial_id\n        if not serial_id or not isinstance(serial_id, str):\n            raise ConfigurationError(\"serial_id must be a non-empty string\")\n        self.serial_id: str = serial_id\n\n        # Set apikey and secret_key\n        self.__apikey = apikey\n        self.__secret_key = secret_key\n\n        # Validate pincode\n        if pincode is not None:\n            if not isinstance(pincode, int):\n                raise ConfigurationError(\"pincode must be an integer\")\n        self.__pincode: int | None = pincode\n\n        # Initialize session and access_token\n        self.session: aiohttp.ClientSession | None = None\n        self.__access_token: str | None = None\n\n        # Set default values for other attributes\n        self.alarm_configuration: AlarmConfiguration | None = None\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Initialize the aiohttp ClientSession.\"\"\"\n        self.session = aiohttp.ClientSession()\n        _LOGGER.info(\"Successfully initialized DiagralAPI session\")\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb) -&gt; None:\n        \"\"\"Close the aiohttp ClientSession.\"\"\"\n        if self.session:\n            await self.session.close()\n\n    async def _request(\n        self, method: str, endpoint: str, timeout: float = 30, **kwargs\n    ) -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Make an asynchronous HTTP request to the specified endpoint.\n\n        Args:\n            method (str): The HTTP method to use for the request (e.g., 'GET', 'POST').\n            endpoint (str): The API endpoint to send the request to.\n            timeout (float, optional): The timeout for the request in seconds. Defaults to 30.\n            **kwargs (any): Additional keyword arguments to pass to the request.\n\n        Returns:\n            tuple[dict[str, Any], int]: A tuple containing:\n                - dict[str, Any]: The JSON response from the API.\n                - int: The HTTP status code of the response.\n\n        Raises:\n            SessionError: If the session is not initialized.\n            DiagralAPIError: If the request results in a 400 status code or other API errors.\n            AuthenticationError: If the request results in a 401 or 403 status code.\n            ValidationError: If the request results in a 422 status code.\n            ServerError: If the request results in a 500 or 503 status code.\n            ClientError: If there is a network error.\n            aiohttp.ContentTypeError: If the response is not valid JSON.\n\n        \"\"\"\n        if not self.session:\n            error_msg = \"Session not initialized from __aenter__.\"\n            _LOGGER.error(error_msg)\n            raise SessionError(error_msg)\n\n        url: str = f\"{BASE_URL}/{API_VERSION}/{endpoint}\"\n        headers: Any = kwargs.pop(\"headers\", {})\n        _LOGGER.debug(\n            \"Sending %s request to %s with headers %s and data %s\",\n            method,\n            url,\n            headers,\n            kwargs.get(\"json\", {}),\n        )\n\n        try:\n            async with self.session.request(\n                method, url, headers=headers, timeout=timeout, **kwargs\n            ) as response:\n                response_data: Any = await response.json()\n                if response.status == 400:\n                    response = HTTPErrorResponse(**response_data)\n                    raise DiagralAPIError(\n                        f\"Bad request - Detail : {response.detail}\",\n                    )\n                if response.status == 401:\n                    response = HTTPErrorResponse(**response_data)\n                    raise AuthenticationError(\n                        f\"Unauthorized - Invalid or expired token - Detail : {response.detail}\"\n                    )\n                if response.status == 403:\n                    response = HTTPErrorResponse(**response_data)\n                    raise AuthenticationError(\n                        f\"Forbidden - The user does not have the right permissions - Detail : {response.detail}\"\n                    )\n                if response.status == 422:\n                    _LOGGER.debug(\"test: %s\", response_data)\n                    response = HTTPValidationError(**response_data)\n                    raise ValidationError(\n                        f\"Validation Error - Detail : {response.detail}\"\n                    )\n                if response.status == 500:\n                    response = HTTPErrorResponse(**response_data)\n                    raise ServerError(\n                        f\"Internal Server Error - Detail : {response.detail}\"\n                    )\n                if response.status == 503:\n                    response = HTTPErrorResponse(**response_data)\n                    raise ServerError(\n                        f\"Service temporarily unavailable - Detail : {response.detail}\"\n                    )\n                if response.status &gt;= 400:\n                    _LOGGER.debug(\n                        \"Received response with status code: %d and content %s\",\n                        response.status,\n                        await response.json(),\n                    )\n                    raise DiagralAPIError(\n                        f\"API error: {response.status} - Error Message : {await response.text()}\",\n                        status_code=response.status,\n                    )\n                return await response.json(), response.status\n        except aiohttp.ContentTypeError as e:\n            raise ValidationError(f\"Invalid JSON response: {e}\") from e\n        except aiohttp.ClientError as e:\n            raise ClientError(f\"Network error: {e}\") from e\n\n    async def login(self) -&gt; None:\n        \"\"\"Asynchronously logs in to the Diagral API using the provided username and password.\n\n        This method sends a POST request to the authentication endpoint with the necessary credentials.\n        If the login is successful, it retrieves and stores the access token.\n        If the login fails, it raises an appropriate error.\n\n        Raises:\n            AuthenticationError: If the login fails or the access token cannot be obtained.\n\n        \"\"\"\n\n        if not self.session:\n            error_msg = \"Session not initialized from __aenter__.\"\n            _LOGGER.error(error_msg)\n            raise SessionError(error_msg)\n\n        _LOGGER.debug(\"Attempting to login to Diagral API\")\n        _DATA: dict[str, str] = {\"username\": self.username, \"password\": self.__password}\n        try:\n            response_data, *_ = await self._request(\n                \"POST\", \"users/authenticate/login?vendor=DIAGRAL\", json=_DATA\n            )\n            _LOGGER.debug(\"Login Response data: %s\", response_data)\n            login_response: LoginResponse = LoginResponse.from_dict(response_data)\n            _LOGGER.debug(\"Login response: %s\", login_response)\n\n            self.__access_token = login_response.access_token\n            if not self.__access_token:\n                error_msg = \"Failed to obtain authentication access_token\"\n                _LOGGER.error(error_msg)\n                raise AuthenticationError(error_msg)\n\n            _LOGGER.info(\"Successfully logged in to Diagral API\")\n        except DiagralAPIError as e:\n            error_msg: str = f\"Failed to login : {e!s}\"\n            _LOGGER.error(error_msg)\n            raise AuthenticationError(error_msg) from e\n\n    async def set_apikey(self) -&gt; ApiKeyWithSecret:\n        \"\"\"Asynchronously set the API key for the Diagral API.\n\n        It sends a request to create a new API key using the current access token.\n        If the API key is successfully created, it verifies the API key to ensure its validity.\n\n        Returns:\n            ApiKeyWithSecret: An instance of ApiKeyWithSecret containing the created API key and secret key.\n\n        Raises:\n            AuthenticationError: If the API key is not found in the response or if the created API key fails validation.\n\n        \"\"\"\n\n        if not self.__access_token:\n            await self.login()\n\n        _DATA: dict[str, str] = {\"serial_id\": self.serial_id}\n        _HEADERS: dict[str, str] = {\n            \"Authorization\": f\"Bearer {self.__access_token}\",\n        }\n\n        try:\n            response_data, *_ = await self._request(\n                \"POST\", \"users/api_key\", json=_DATA, headers=_HEADERS\n            )\n            set_apikey_response: ApiKeyWithSecret = ApiKeyWithSecret.from_dict(\n                response_data\n            )\n            self.__apikey = set_apikey_response.api_key\n            if not self.__apikey:\n                error_msg = \"API key not found in response\"\n                _LOGGER.error(error_msg)\n                raise AuthenticationError(error_msg)\n            self.__secret_key = set_apikey_response.secret_key\n            if not self.__secret_key:\n                error_msg = \"Secret key not found in response\"\n                _LOGGER.error(error_msg)\n                raise AuthenticationError(error_msg)\n\n            _LOGGER.info(\"Successfully created new API key: ...%s\", self.__apikey[-4:])\n            # Verify if the API key is valid\n            try:\n                await self.validate_apikey()\n                _LOGGER.info(\n                    \"Successfully verified new API key: ...%s\", self.__apikey[-4:]\n                )\n            except AuthenticationError as e:\n                _LOGGER.error(\"Created API key failed validation: %s\", e)\n                self.__apikey = None\n                raise\n        except DiagralAPIError as e:\n            error_msg: str = f\"Failed to create API key: {e!s}\"\n            _LOGGER.error(error_msg)\n            raise AuthenticationError(error_msg) from e\n\n        return ApiKeyWithSecret(api_key=self.__apikey, secret_key=self.__secret_key)\n\n    async def validate_apikey(self, apikey: str | None = None) -&gt; None:\n        \"\"\"Validate the current or provided API key by checking it against the list of valid keys.\n\n        This method performs the following steps:\n        1. Checks if the API key is available. If not, logs a warning and raises an AuthenticationError.\n        2. Ensures that an access token is available by calling the login method if necessary.\n        3. Sends a GET request to retrieve the list of valid API keys associated with the user's system.\n        4. Checks if the current or provided API key is in the list of valid keys.\n        5. Logs a success message if the API key is valid, otherwise raises an AuthenticationError.\n\n        Args:\n            apikey (str | None, optional): The API key to validate. If not provided, the instance's API key is used. Defaults to None.\n\n        Raises:\n            ConfigurationError: If no API key is provided or if the API key is invalid.\n\n        \"\"\"\n\n        apikey_to_validate: str = apikey or self.__apikey\n\n        if not apikey_to_validate:\n            _LOGGER.warning(\"No API key provided to validate\")\n            raise ConfigurationError(\"No API key provided to validate\")\n\n        if not self.__access_token:\n            await self.login()\n\n        _HEADERS: dict[str, str] = {\n            \"Authorization\": f\"Bearer {self.__access_token}\",\n        }\n        response_data, *_ = await self._request(\n            \"GET\",\n            f\"users/systems/{self.serial_id}/api_keys\",\n            headers=_HEADERS,\n        )\n        validate_apikey_response: ApiKeys = ApiKeys.from_dict(response_data)\n        is_valid = any(\n            key_info.api_key == apikey_to_validate\n            for key_info in validate_apikey_response.api_keys\n        )\n        if is_valid:\n            _LOGGER.info(\"API key successfully validated\")\n        else:\n            raise AuthenticationError(\n                \"API key is invalid or not found in the list of valid keys\"\n            )\n\n    async def delete_apikey(self, apikey: str | None = None) -&gt; None:\n        \"\"\"Asynchronously delete the specified or current API key.\n\n        This method deletes the API key associated with the instance or the provided API key.\n        If the API key is not available, it raises an AuthenticationError. If the access token\n        is not available, it attempts to log in to obtain one. The method then sends a DELETE\n        request to the appropriate endpoint to delete the API key. Upon successful deletion,\n        it logs an informational message and sets the `apikey` and `secret_key` attributes to None.\n\n        Args:\n            apikey (str | None, optional): The API key to delete. If not provided, the instance's API key is used. Defaults to None.\n\n        Raises:\n            AuthenticationError: If the API key is not available.\n\n        \"\"\"\n\n        apikey_to_delete: str = apikey or self.__apikey\n\n        if not apikey_to_delete:\n            raise AuthenticationError(\"An API key is required to delete it\")\n\n        if not self.__access_token:\n            await self.login()\n\n        _HEADERS: dict[str, str] = {\n            \"Authorization\": f\"Bearer {self.__access_token}\",\n        }\n        await self._request(\n            \"DELETE\",\n            f\"users/systems/{self.serial_id}/api_keys/{apikey_to_delete}\",\n            headers=_HEADERS,\n        )\n        _LOGGER.info(\"Successfully deleted API key: ...%s\", apikey_to_delete[-4:])\n\n        if apikey is None:\n            self.__apikey = None\n            self.__secret_key = None\n\n    async def try_connection(self, ephemeral: bool = True) -&gt; TryConnectResult:\n        \"\"\"Test connection with the Diagral system.\n\n        This method tests the connection by either using provided API credentials or generating\n        temporary ones. It validates the connection by checking the system status.\n\n        Args:\n            ephemeral (bool, optional): If True, temporary API keys will be deleted after\n                connection test. Defaults to True.\n\n        Returns:\n            TryConnectResult: Object containing connection test results and optionally API keys\n                if non-ephemeral temporary keys were generated.\n\n        Raises:\n            DiagralAPIError: If connection attempt fails or system status check fails.\n\n        Note:\n            If API credentials are not provided during client initialization, temporary\n            keys will be generated (if ephemeral) for the connection test. These keys will be:\n            - Deleted after the test if ephemeral=True\n            - Returned in the result if ephemeral=False\n\n        \"\"\"\n\n        result: TryConnectResult = TryConnectResult()\n        api_keys_provided = bool(self.__apikey and self.__secret_key)\n        try:\n            # If API keys are not provided, generate temporary keys\n            if not api_keys_provided:\n                api_key_response: ApiKeyWithSecret = await self.set_apikey()\n\n            # Retrieve system status to validate connection\n            await self.get_system_status()\n            # If connection is successful, clean up temporary keys if requested (ephemeral)\n            if ephemeral and not api_keys_provided:\n                await self.delete_apikey(apikey=self.__apikey)\n            elif not ephemeral and not api_keys_provided:\n                result.keys = api_key_response\n        except DiagralAPIError as e:\n            raise DiagralAPIError(f\"Failed to connect to the system: {e}\") from e\n        result.result = True\n        return result\n\n    async def get_configuration(self) -&gt; None:\n        \"\"\"Asynchronously retrieve the configuration of the Diagral system.\n\n        This method retrieves the configuration of the Diagral system by sending a GET\n        request to the appropriate endpoint. If the access token is not available, it\n        attempts to log in to obtain one. Upon successful retrieval, it logs an informational\n        message with the configuration details. The retrieved configuration is stored in\n        the self.alarm_configuration attribute, allowing it to be reused within the same\n        session without needing to collect it multiple times.\n\n        Returns:\n            AlarmConfiguration: The configuration details of the Diagral system.\n\n        Raises:\n            AuthenticationError: If the access token is not available.\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get configuration\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"GET\", f\"systems/{self.serial_id}/configurations\", headers=_HEADERS\n        )\n        self.alarm_configuration = AlarmConfiguration.from_dict(response_data)\n        _LOGGER.debug(\n            \"Successfully retrieved configuration: %s\", self.alarm_configuration\n        )\n        return self.alarm_configuration\n\n    async def get_alarm_name(self) -&gt; str:\n        \"\"\"Get the name of the alarm from the configuration.\n\n        Returns:\n            str: The name of the alarm from the configuration.\n\n        Raises:\n            ConfigurationError: If unable to retrieve the alarm configuration.\n\n        Note:\n            This method will attempt to fetch the configuration if it hasn't been loaded yet.\n\n        \"\"\"\n\n        if not self.alarm_configuration:\n            await self.get_configuration()\n\n        if not self.alarm_configuration:\n            raise ConfigurationError(\"Failed to retrieve alarm configuration\")\n\n        return self.alarm_configuration.alarm.name\n\n    async def get_devices_info(self) -&gt; DeviceList:\n        \"\"\"Asynchronously retrieves information about various device types from the alarm configuration.\n\n        The method retrieve information for each device type (cameras, commands, sensors, sirens,\n        transmitters) from the alarm configuration, and compiles this information into a dictionary.\n\n        Returns:\n            dict: A dictionary where the keys are device types and the values are lists of dictionaries\n            containing device information (index and label).\n\n        Raises:\n            ConfigurationError: If the alarm configuration cannot be retrieved.\n\n        \"\"\"\n\n        if not self.alarm_configuration:\n            await self.get_configuration()\n\n        if not self.alarm_configuration:\n            raise ConfigurationError(\"Failed to retrieve alarm configuration\")\n\n        device_types: list[str] = sorted(\n            [\"cameras\", \"commands\", \"sensors\", \"sirens\", \"transmitters\"]\n        )\n        devices_infos = {}\n        for device_type in device_types:\n            _LOGGER.debug(\"Retrieving devices information for %s\", device_type)\n            devices: Any | None = getattr(self.alarm_configuration, device_type, None)\n            if devices is not None:\n                devices_infos[device_type] = [\n                    {\"index\": device.index, \"label\": device.label} for device in devices\n                ]\n            else:\n                devices_infos[device_type] = []\n        _LOGGER.debug(\"Successfully retrieved devices information: %s\", devices_infos)\n        return DeviceList.from_dict(devices_infos)\n\n    async def get_system_details(self) -&gt; SystemDetails:\n        \"\"\"Asynchronously retrieves the system details.\n\n        This method fetches the system details using the provided API key, secret key,\n        and PIN code. It generates the necessary HMAC signature and includes it in the\n        request headers.\n\n        Returns:\n            SystemDetails: An instance of SystemDetails containing the retrieved system information.\n\n        Raises:\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        if not self.__pincode:\n            raise AuthenticationError(\"PIN code required to get system details\")\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-PIN-CODE\": str(self.__pincode),\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"GET\", f\"systems/{self.serial_id}\", headers=_HEADERS\n        )\n        _LOGGER.debug(\"Successfully retrieved system details: %s\", response_data)\n        return SystemDetails.from_dict(response_data)\n\n    async def get_system_status(self) -&gt; SystemStatus:\n        \"\"\"Asynchronously retrieves the system status.\n\n        This method fetches the current status of the system using the provided API key,\n        secret key, and PIN code. It generates an HMAC signature for authentication and\n        sends a GET request to the system status endpoint.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the retrieved system status.\n\n        Raises:\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        if not self.__pincode:\n            raise AuthenticationError(\"PIN code required to get system details\")\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-PIN-CODE\": str(self.__pincode),\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"GET\", f\"systems/{self.serial_id}/status\", headers=_HEADERS\n        )\n        _LOGGER.debug(\"Successfully retrieved system status: %s\", response_data)\n        return SystemStatus.from_dict(response_data)\n\n    async def __system_action(self, action: str) -&gt; SystemStatus:\n        \"\"\"Perform a system action such as start, stop, presence, partial start 1, or partial start 2.\n\n        Args:\n            action (str): The action to perform. Must be one of 'start', 'stop', 'presence', 'partial_start_1', or 'partial_start_2'.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after performing the action.\n\n        Raises:\n            ConfigurationError: If the action is not one of the allowed actions.\n            AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n        \"\"\"\n\n        if action not in [\n            \"start\",\n            \"stop\",\n            \"presence\",\n            \"partial_start_1\",\n            \"partial_start_2\",\n        ]:\n            raise ConfigurationError(\n                \"Action must be one of 'start', 'stop', 'presence', 'partial_start_1', or 'partial_start_2'\"\n            )\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        if not self.__pincode:\n            raise AuthenticationError(f\"PIN code required to do system action {action}\")\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-PIN-CODE\": str(self.__pincode),\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"POST\", f\"systems/{self.serial_id}/{action}\", headers=_HEADERS\n        )\n        _LOGGER.debug(\n            \"Successfully performed action %s: %s\", action.upper(), response_data\n        )\n        return SystemStatus.from_dict(response_data)\n\n    async def start_system(self) -&gt; SystemStatus:\n        \"\"\"Asynchronously starts the system.\n\n        This method sends a request to start the system and returns the system status.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after starting the system.\n\n        Raises:\n            ConfigurationError: If the action is not one of the allowed actions.\n            AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n        \"\"\"\n\n        return await self.__system_action(\"start\")\n\n    async def stop_system(self) -&gt; SystemStatus:\n        \"\"\"Asynchronously stops the system.\n\n        This method sends a request to stop the system and returns the system status.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after stopping the system.\n\n        Raises:\n            ConfigurationError: If the action is not one of the allowed actions.\n            AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n        \"\"\"\n\n        return await self.__system_action(\"stop\")\n\n    async def presence(self) -&gt; SystemStatus:\n        \"\"\"Asynchronously starts the system in presence mode.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after starting the system in presence mode.\n\n        Raises:\n            ConfigurationError: If the action is not one of the allowed actions.\n            AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n        \"\"\"\n\n        return await self.__system_action(\"presence\")\n\n    async def partial_start_system(self, id: int = 1) -&gt; SystemStatus:  # NOT-TESTED\n        \"\"\"Initiate a partial start of the system.\n\n        Args:\n            id (int, optional): The ID of the partial start. Must be either 1 or 2. Defaults to 1.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after performing the partial start.\n\n        Raises:\n            ConfigurationError: If the provided ID is not 1 or 2.\n\n        \"\"\"\n\n        if id not in [1, 2]:\n            raise ConfigurationError(\"Partial Start Id must be 1 or 2\")\n\n        return await self.__system_action(f\"partial_start_{id}\")\n\n    async def __action_group_system(\n        self, action: str, groups: list[int]\n    ) -&gt; SystemStatus:  # TO-TEST\n        \"\"\"Perform an action on a group of systems.\n\n        This method activates or disables a group of systems based on the provided action.\n\n        Args:\n            action (str): The action to perform. Must be either 'activate_group' or 'disable_group'.\n            groups (list[int]): A list of group indices to perform the action on.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after performing the action.\n\n        Raises:\n            ConfigurationError: If the action is not 'activate_group' or 'disable_group', or if the groups are invalid.\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n\n        if action not in [\"activate_group\", \"disable_group\"]:\n            raise ConfigurationError(\n                \"Action must be either 'activate_group' or 'disable_group'\"\n            )\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        if not self.__pincode:\n            raise AuthenticationError(\"PIN code required to get system details\")\n\n        # Get the configuration if it is not already available\n        if not self.alarm_configuration:\n            await self.get_configuration()\n\n        # Check if the groups are valid\n        invalid_groups: list[int] = [\n            group\n            for group in groups\n            if group not in [g.index for g in self.alarm_configuration.groups]\n        ]\n        if invalid_groups:\n            raise ConfigurationError(\n                f\"The following groups do not exist in your system: {invalid_groups}\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-PIN-CODE\": str(self.__pincode),\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        data: dict[str, list[int]] = {\"groups\": groups}\n        response_data, *_ = await self._request(\n            \"POST\",\n            f\"systems/{self.serial_id}/{action}\",\n            headers=_HEADERS,\n            json=data,\n        )\n        _LOGGER.debug(\n            \"Successfully %s %s: %s\", action.replace(\"_\", \" \"), groups, response_data\n        )\n        return SystemStatus.from_dict(response_data)\n\n    async def activate_group(self, groups: list[int]) -&gt; SystemStatus:\n        \"\"\"Asynchronously activates a group of systems.\n\n        Args:\n            groups (list[int]): A list of integers representing the groups to be activated.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after activating the groups.\n\n        Raises:\n            ConfigurationError: If the action is not one of the allowed actions.\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n\n        if not isinstance(groups, list) or not all(\n            isinstance(item, int) for item in groups\n        ):\n            raise ConfigurationError(\"Groups must be a list of integers\")\n\n        return await self.__action_group_system(\"activate_group\", groups)\n\n    async def disable_group(self, groups: list[int]) -&gt; SystemStatus:\n        \"\"\"Asynchronously disables a group of systems.\n\n        Args:\n            groups (list[int]): A list of integers representing the groups to disable.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after disabling the groups.\n\n        Raises:\n            ConfigurationError: If the action is not one of the allowed actions.\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n\n        if not isinstance(groups, list) or not all(\n            isinstance(item, int) for item in groups\n        ):\n            raise ConfigurationError(\"Groups must be a list of integers\")\n\n        return await self.__action_group_system(\"disable_group\", groups)\n\n    async def __action_product(\n        self, action: str, type: str, product_id: int\n    ) -&gt; SystemStatus:  # NOT-TESTED\n        \"\"\"Perform an action on a product in the Diagral system.\n\n        This method enables or disables a product based on the provided action.\n\n        Args:\n            action (str): The action to perform. Must be either 'enable' or 'disable'.\n            type (str): The type of product to perform the action on.\n            product_id (int): The ID of the product to perform the action on.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after performing the action.\n\n        Raises:\n            ConfigurationError: If the action is not 'enable' or 'disable', or if the product type is invalid.\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n\n        if action not in [\"enable\", \"disable\"]:\n            raise ConfigurationError(\"Action must be either 'enable' or 'disable'\")\n\n        if type not in [\"CENTRAL\", \"SENSOR\", \"COMMAND\", \"ALARM\", \"BOX\", \"PLUG\"]:\n            raise ConfigurationError(\n                \"Product type must be one of 'CENTRAL', 'SENSOR', 'COMMAND', 'ALARM', 'BOX', or 'PLUG'\"\n            )\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        if not self.__pincode:\n            raise AuthenticationError(\"PIN code required to get system details\")\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-PIN-CODE\": str(self.__pincode),\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"POST\",\n            f\"systems/{self.serial_id}/{type}/{product_id}/{action}\",\n            headers=_HEADERS,\n        )\n        return SystemStatus.from_dict(response_data)\n\n    async def enable_product(\n        self, type: str, product_id: int\n    ) -&gt; SystemStatus:  # NOT-TESTED\n        \"\"\"Asynchronously enables a product in the system.\n\n        Args:\n            type (str): The type of the product to enable.\n            product_id (int): The unique identifier of the product to enable.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after enabling the product.\n\n        Raises:\n            ConfigurationError: If the action is not 'enable'\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n        return await self.__action_product(\n            action=\"enable\", type=type, product_id=product_id\n        )\n\n    async def disable_product(\n        self, type: str, product_id: int\n    ) -&gt; SystemStatus:  # NOT-TESTED\n        \"\"\"Asynchronously enables a product in the system.\n\n        Args:\n            type (str): The type of the product to enable.\n            product_id (int): The unique identifier of the product to enable.\n\n        Returns:\n            SystemStatus: An instance of SystemStatus containing the system status after disabling the product.\n\n        Raises:\n            ConfigurationError: If the action is not 'disable'\n            AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n        \"\"\"\n        return await self.__action_product(\n            action=\"disable\", type=type, product_id=product_id\n        )\n\n    async def get_anomalies(self) -&gt; Anomalies | dict:\n        \"\"\"Asynchronously retrieves anomalies for the system.\n\n        This method fetches the anomalies associated with the system identified by the serial ID. It requires valid API key and secret key for authentication.\n\n        Returns:\n            Anomalies | dict: An instance of the Anomalies class populated with the data retrieved from the API, or an empty dictionary if no anomalies are found.\n\n        Raises:\n            AuthenticationError: If the API key or secret key is not provided.\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        try:\n            response_data, *_ = await self._request(\n                \"GET\",\n                f\"systems/{self.serial_id}/anomalies\",\n                headers=_HEADERS,\n            )\n        except DiagralAPIError as e:\n            if e.status_code == 404 and \"No anomalies found\" in e.message:\n                _LOGGER.info(\"No anomalies found for the system\")\n                return {}\n        return Anomalies.from_dict(response_data)\n\n    async def delete_anomalies(self, anomaly_id: int) -&gt; None:  # NOT-IMPLEMENTED\n        \"\"\"Asynchronously delete the list of anomalies.\n\n        This method is currently not implemented.\n\n        Raises:\n            NotImplementedError: This method is not yet implemented.\n\n        \"\"\"\n        raise NotImplementedError(\"Method not yet implemented\")\n\n    async def get_automatism_rudes(self) -&gt; Rudes:  # NOT-TESTED\n        \"\"\"Asynchronously retrieves the automatism Rudes for the system.\n\n        This method fetches the Rudes data for the system identified by the serial ID.\n        It requires valid API and secret keys for authentication.\n\n        Returns:\n            Rudes: An instance of the Rudes class populated with the data from the response.\n\n        Raises:\n            AuthenticationError: If the API key or secret key is not provided.\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"GET\",\n            f\"systems/{self.serial_id}/rudes\",\n            headers=_HEADERS,\n        )\n        return Rudes.from_dict(response_data)\n\n    async def set_automatism_action(\n        self, canal: str, action: str\n    ) -&gt; None:  # NOT-IMPLEMENTED\n        \"\"\"Set the automatism action.\n\n        This method is currently not implemented.\n\n        Args:\n            canal (str): The canal for the automatism action.\n            action (str): The action to be set for the automatism.\n\n        Raises:\n            NotImplementedError: Always, as this method is not yet implemented.\n\n        \"\"\"\n        raise NotImplementedError(\"Method not yet implemented\")\n\n    async def get_webhook(self) -&gt; Webhook:\n        \"\"\"Retrieve the webhook subscription details for the system.\n\n        Returns:\n            Webhook: An instance of the Webhook class containing the subscription details.\n\n        Raises:\n            AuthenticationError: If the API key or secret key is not provided.\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"GET\",\n            f\"webhooks/{self.serial_id}/subscription\",\n            headers=_HEADERS,\n        )\n        return Webhook.from_dict(response_data)\n\n    async def __webhook_action_create_update(\n        self,\n        action: str,\n        webhook_url: str,\n        subscribe_to_anomaly: bool = False,\n        subscribe_to_alert: bool = False,\n        subscribe_to_state: bool = False,\n    ) -&gt; Webhook | None:\n        \"\"\"Create or update a webhook subscription.\n\n        Args:\n            action (str): The action to perform, either 'register' or 'update'.\n            webhook_url (str): The URL of the webhook to register or update.\n            subscribe_to_anomaly (bool, optional): Whether to subscribe to anomaly notifications. Defaults to False.\n            subscribe_to_alert (bool, optional): Whether to subscribe to alert notifications. Defaults to False.\n            subscribe_to_state (bool, optional): Whether to subscribe to state notifications. Defaults to False.\n\n        Returns:\n            Webhook | None: The created or updated Webhook object, or None if registration is skipped.\n\n        Raises:\n            ConfigurationError: If the action is not 'register' or 'update'.\n            AuthenticationError: If the API key or secret key is missing.\n            ValidationError: If the webhook URL is invalid or if the subscription already exists.\n\n        \"\"\"\n        if action not in [\"register\", \"update\"]:\n            raise ConfigurationError(\"Action must be either 'register' or 'update'\")\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        if action == \"register\" and not any(\n            [subscribe_to_anomaly, subscribe_to_alert, subscribe_to_state]\n        ):\n            _LOGGER.warning(\"No subscriptions selected, skipping webhook registration\")\n            return None\n\n        if not re.match(r\"^https?://\", webhook_url):\n            raise ValidationError(\n                \"Invalid webhook URL. Must start with http:// or https://\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        data = {\n            \"webhook_url\": webhook_url,\n            \"subscribe_to_anomaly\": subscribe_to_anomaly,\n            \"subscribe_to_alert\": subscribe_to_alert,\n            \"subscribe_to_state\": subscribe_to_state,\n        }\n        method = \"POST\" if action == \"register\" else \"PUT\"\n        try:\n            response_data, *_ = await self._request(\n                method,\n                f\"webhooks/{self.serial_id}/subscription\",\n                headers=_HEADERS,\n                json=data,\n            )\n        except DiagralAPIError as e:\n            if \"Subscription already exists\" in str(e):\n                raise DiagralAPIError(\n                    \"Webhook subscription already exists. Please use the 'update' action to modify it.\"\n                ) from e\n            if \"There is no subscription for\" in str(e):\n                raise DiagralAPIError(\n                    \"No subscription found for the specified serial ID\"\n                ) from e\n        return Webhook.from_dict(response_data)\n\n    async def register_webhook(\n        self,\n        webhook_url: str,\n        subscribe_to_anomaly: bool = False,\n        subscribe_to_alert: bool = False,\n        subscribe_to_state: bool = False,\n    ) -&gt; Webhook | None:\n        \"\"\"Register a webhook with the specified URL and subscription options.\n\n        Args:\n            webhook_url (str): The URL to which the webhook will send data.\n            subscribe_to_anomaly (bool, optional): If True, subscribe to anomaly events. Defaults to False.\n            subscribe_to_alert (bool, optional): If True, subscribe to alert events. Defaults to False.\n            subscribe_to_state (bool, optional): If True, subscribe to state events. Defaults to False.\n\n        Returns:\n            Webhook | None: The registered Webhook object if successful, otherwise None.\n\n        \"\"\"\n        return await self.__webhook_action_create_update(\n            \"register\",\n            webhook_url,\n            subscribe_to_anomaly,\n            subscribe_to_alert,\n            subscribe_to_state,\n        )\n\n    async def update_webhook(\n        self,\n        webhook_url: str,\n        subscribe_to_anomaly: bool = False,\n        subscribe_to_alert: bool = False,\n        subscribe_to_state: bool = False,\n    ) -&gt; Webhook | None:\n        \"\"\"Update the webhook configuration with the specified parameters.\n\n        Args:\n            webhook_url (str): The URL of the webhook to update.\n            subscribe_to_anomaly (bool, optional): Whether to subscribe to anomaly notifications. Defaults to False.\n            subscribe_to_alert (bool, optional): Whether to subscribe to alert notifications. Defaults to False.\n            subscribe_to_state (bool, optional): Whether to subscribe to state notifications. Defaults to False.\n\n        Returns:\n            Webhook | None: The registered Webhook object if successful, otherwise None.\n\n        \"\"\"\n        return await self.__webhook_action_create_update(\n            \"update\",\n            webhook_url,\n            subscribe_to_anomaly,\n            subscribe_to_alert,\n            subscribe_to_state,\n        )\n\n    async def delete_webhook(self) -&gt; None:\n        \"\"\"Asynchronously deletes the webhook subscription for the current system.\n\n        Raises:\n            AuthenticationError: If the API key or secret key is not provided.\n\n        Returns:\n            None\n\n        \"\"\"\n\n        if not self.__apikey or not self.__secret_key:\n            raise AuthenticationError(\n                \"API key and secret key required to get system details\"\n            )\n\n        _TIMESTAMP = str(int(time.time()))\n        _HMAC: str = generate_hmac_signature(\n            timestamp=_TIMESTAMP,\n            serial_id=self.serial_id,\n            api_key=self.__apikey,\n            secret_key=self.__secret_key,\n        )\n\n        _HEADERS: dict[str, str] = {\n            \"X-HMAC\": _HMAC,\n            \"X-TIMESTAMP\": _TIMESTAMP,\n            \"X-APIKEY\": self.__apikey,\n        }\n        response_data, *_ = await self._request(\n            \"DELETE\",\n            f\"webhooks/{self.serial_id}/subscription\",\n            headers=_HEADERS,\n        )\n\n    @staticmethod\n    def __is_valid_email(email: str) -&gt; bool:\n        \"\"\"Validate the format of an email address.\n\n        Args:\n            email (str): The email address to validate.\n\n        Returns:\n            bool: True if the email is valid, False otherwise.\n\n        \"\"\"\n        email_regex = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        return re.match(email_regex, email) is not None\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__init__","title":"<code>__init__(username, password, serial_id, apikey=None, secret_key=None, pincode=None)</code>","text":"<p>Initialize the DiagralAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The email address for Diagral API authentication.</p> required <code>password</code> <code>str</code> <p>The password for Diagral API authentication.</p> required <code>serial_id</code> <code>str</code> <p>The serial ID of the Diagral system.</p> required <code>apikey</code> <code>str | None</code> <p>The API key for additional authentication. Defaults to None.</p> <code>None</code> <code>secret_key</code> <code>str | None</code> <p>The secret key for additional authentication. Defaults to None.</p> <code>None</code> <code>pincode</code> <code>int | None</code> <p>The PIN code for the Diagral system. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any required field is empty or invalid.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    serial_id: str,\n    apikey: str | None = None,\n    secret_key: str | None = None,\n    pincode: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the DiagralAPI instance.\n\n    Args:\n        username (str): The email address for Diagral API authentication.\n        password (str): The password for Diagral API authentication.\n        serial_id (str): The serial ID of the Diagral system.\n        apikey (str | None, optional): The API key for additional authentication. Defaults to None.\n        secret_key (str | None, optional): The secret key for additional authentication. Defaults to None.\n        pincode (int | None, optional): The PIN code for the Diagral system. Defaults to None.\n\n    Raises:\n        ConfigurationError: If any required field is empty or invalid.\n\n    \"\"\"\n    # Validate username as an email\n    if (\n        not username\n        or not isinstance(username, str)\n        or not self.__is_valid_email(username)\n    ):\n        raise ConfigurationError(\"username must be a valid non-empty email address\")\n    self.username: str = username\n\n    # Validate password\n    if not password or not isinstance(password, str):\n        raise ConfigurationError(\"password must be a non-empty string\")\n    self.__password: str = password\n\n    # Validate serial_id\n    if not serial_id or not isinstance(serial_id, str):\n        raise ConfigurationError(\"serial_id must be a non-empty string\")\n    self.serial_id: str = serial_id\n\n    # Set apikey and secret_key\n    self.__apikey = apikey\n    self.__secret_key = secret_key\n\n    # Validate pincode\n    if pincode is not None:\n        if not isinstance(pincode, int):\n            raise ConfigurationError(\"pincode must be an integer\")\n    self.__pincode: int | None = pincode\n\n    # Initialize session and access_token\n    self.session: aiohttp.ClientSession | None = None\n    self.__access_token: str | None = None\n\n    # Set default values for other attributes\n    self.alarm_configuration: AlarmConfiguration | None = None\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Initialize the aiohttp ClientSession.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Initialize the aiohttp ClientSession.\"\"\"\n    self.session = aiohttp.ClientSession()\n    _LOGGER.info(\"Successfully initialized DiagralAPI session\")\n    return self\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__aexit__","title":"<code>__aexit__(exc_type, exc, tb)</code>  <code>async</code>","text":"<p>Close the aiohttp ClientSession.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def __aexit__(self, exc_type, exc, tb) -&gt; None:\n    \"\"\"Close the aiohttp ClientSession.\"\"\"\n    if self.session:\n        await self.session.close()\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI._request","title":"<code>_request(method, endpoint, timeout=30, **kwargs)</code>  <code>async</code>","text":"<p>Make an asynchronous HTTP request to the specified endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use for the request (e.g., 'GET', 'POST').</p> required <code>endpoint</code> <code>str</code> <p>The API endpoint to send the request to.</p> required <code>timeout</code> <code>float</code> <p>The timeout for the request in seconds. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>any</code> <p>Additional keyword arguments to pass to the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[dict[str, Any], int]</code> <p>tuple[dict[str, Any], int]: A tuple containing: - dict[str, Any]: The JSON response from the API. - int: The HTTP status code of the response.</p> <p>Raises:</p> Type Description <code>SessionError</code> <p>If the session is not initialized.</p> <code>DiagralAPIError</code> <p>If the request results in a 400 status code or other API errors.</p> <code>AuthenticationError</code> <p>If the request results in a 401 or 403 status code.</p> <code>ValidationError</code> <p>If the request results in a 422 status code.</p> <code>ServerError</code> <p>If the request results in a 500 or 503 status code.</p> <code>ClientError</code> <p>If there is a network error.</p> <code>ContentTypeError</code> <p>If the response is not valid JSON.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def _request(\n    self, method: str, endpoint: str, timeout: float = 30, **kwargs\n) -&gt; tuple[dict[str, Any], int]:\n    \"\"\"Make an asynchronous HTTP request to the specified endpoint.\n\n    Args:\n        method (str): The HTTP method to use for the request (e.g., 'GET', 'POST').\n        endpoint (str): The API endpoint to send the request to.\n        timeout (float, optional): The timeout for the request in seconds. Defaults to 30.\n        **kwargs (any): Additional keyword arguments to pass to the request.\n\n    Returns:\n        tuple[dict[str, Any], int]: A tuple containing:\n            - dict[str, Any]: The JSON response from the API.\n            - int: The HTTP status code of the response.\n\n    Raises:\n        SessionError: If the session is not initialized.\n        DiagralAPIError: If the request results in a 400 status code or other API errors.\n        AuthenticationError: If the request results in a 401 or 403 status code.\n        ValidationError: If the request results in a 422 status code.\n        ServerError: If the request results in a 500 or 503 status code.\n        ClientError: If there is a network error.\n        aiohttp.ContentTypeError: If the response is not valid JSON.\n\n    \"\"\"\n    if not self.session:\n        error_msg = \"Session not initialized from __aenter__.\"\n        _LOGGER.error(error_msg)\n        raise SessionError(error_msg)\n\n    url: str = f\"{BASE_URL}/{API_VERSION}/{endpoint}\"\n    headers: Any = kwargs.pop(\"headers\", {})\n    _LOGGER.debug(\n        \"Sending %s request to %s with headers %s and data %s\",\n        method,\n        url,\n        headers,\n        kwargs.get(\"json\", {}),\n    )\n\n    try:\n        async with self.session.request(\n            method, url, headers=headers, timeout=timeout, **kwargs\n        ) as response:\n            response_data: Any = await response.json()\n            if response.status == 400:\n                response = HTTPErrorResponse(**response_data)\n                raise DiagralAPIError(\n                    f\"Bad request - Detail : {response.detail}\",\n                )\n            if response.status == 401:\n                response = HTTPErrorResponse(**response_data)\n                raise AuthenticationError(\n                    f\"Unauthorized - Invalid or expired token - Detail : {response.detail}\"\n                )\n            if response.status == 403:\n                response = HTTPErrorResponse(**response_data)\n                raise AuthenticationError(\n                    f\"Forbidden - The user does not have the right permissions - Detail : {response.detail}\"\n                )\n            if response.status == 422:\n                _LOGGER.debug(\"test: %s\", response_data)\n                response = HTTPValidationError(**response_data)\n                raise ValidationError(\n                    f\"Validation Error - Detail : {response.detail}\"\n                )\n            if response.status == 500:\n                response = HTTPErrorResponse(**response_data)\n                raise ServerError(\n                    f\"Internal Server Error - Detail : {response.detail}\"\n                )\n            if response.status == 503:\n                response = HTTPErrorResponse(**response_data)\n                raise ServerError(\n                    f\"Service temporarily unavailable - Detail : {response.detail}\"\n                )\n            if response.status &gt;= 400:\n                _LOGGER.debug(\n                    \"Received response with status code: %d and content %s\",\n                    response.status,\n                    await response.json(),\n                )\n                raise DiagralAPIError(\n                    f\"API error: {response.status} - Error Message : {await response.text()}\",\n                    status_code=response.status,\n                )\n            return await response.json(), response.status\n    except aiohttp.ContentTypeError as e:\n        raise ValidationError(f\"Invalid JSON response: {e}\") from e\n    except aiohttp.ClientError as e:\n        raise ClientError(f\"Network error: {e}\") from e\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.login","title":"<code>login()</code>  <code>async</code>","text":"<p>Asynchronously logs in to the Diagral API using the provided username and password.</p> <p>This method sends a POST request to the authentication endpoint with the necessary credentials. If the login is successful, it retrieves and stores the access token. If the login fails, it raises an appropriate error.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the login fails or the access token cannot be obtained.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def login(self) -&gt; None:\n    \"\"\"Asynchronously logs in to the Diagral API using the provided username and password.\n\n    This method sends a POST request to the authentication endpoint with the necessary credentials.\n    If the login is successful, it retrieves and stores the access token.\n    If the login fails, it raises an appropriate error.\n\n    Raises:\n        AuthenticationError: If the login fails or the access token cannot be obtained.\n\n    \"\"\"\n\n    if not self.session:\n        error_msg = \"Session not initialized from __aenter__.\"\n        _LOGGER.error(error_msg)\n        raise SessionError(error_msg)\n\n    _LOGGER.debug(\"Attempting to login to Diagral API\")\n    _DATA: dict[str, str] = {\"username\": self.username, \"password\": self.__password}\n    try:\n        response_data, *_ = await self._request(\n            \"POST\", \"users/authenticate/login?vendor=DIAGRAL\", json=_DATA\n        )\n        _LOGGER.debug(\"Login Response data: %s\", response_data)\n        login_response: LoginResponse = LoginResponse.from_dict(response_data)\n        _LOGGER.debug(\"Login response: %s\", login_response)\n\n        self.__access_token = login_response.access_token\n        if not self.__access_token:\n            error_msg = \"Failed to obtain authentication access_token\"\n            _LOGGER.error(error_msg)\n            raise AuthenticationError(error_msg)\n\n        _LOGGER.info(\"Successfully logged in to Diagral API\")\n    except DiagralAPIError as e:\n        error_msg: str = f\"Failed to login : {e!s}\"\n        _LOGGER.error(error_msg)\n        raise AuthenticationError(error_msg) from e\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.set_apikey","title":"<code>set_apikey()</code>  <code>async</code>","text":"<p>Asynchronously set the API key for the Diagral API.</p> <p>It sends a request to create a new API key using the current access token. If the API key is successfully created, it verifies the API key to ensure its validity.</p> <p>Returns:</p> Name Type Description <code>ApiKeyWithSecret</code> <code>ApiKeyWithSecret</code> <p>An instance of ApiKeyWithSecret containing the created API key and secret key.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key is not found in the response or if the created API key fails validation.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def set_apikey(self) -&gt; ApiKeyWithSecret:\n    \"\"\"Asynchronously set the API key for the Diagral API.\n\n    It sends a request to create a new API key using the current access token.\n    If the API key is successfully created, it verifies the API key to ensure its validity.\n\n    Returns:\n        ApiKeyWithSecret: An instance of ApiKeyWithSecret containing the created API key and secret key.\n\n    Raises:\n        AuthenticationError: If the API key is not found in the response or if the created API key fails validation.\n\n    \"\"\"\n\n    if not self.__access_token:\n        await self.login()\n\n    _DATA: dict[str, str] = {\"serial_id\": self.serial_id}\n    _HEADERS: dict[str, str] = {\n        \"Authorization\": f\"Bearer {self.__access_token}\",\n    }\n\n    try:\n        response_data, *_ = await self._request(\n            \"POST\", \"users/api_key\", json=_DATA, headers=_HEADERS\n        )\n        set_apikey_response: ApiKeyWithSecret = ApiKeyWithSecret.from_dict(\n            response_data\n        )\n        self.__apikey = set_apikey_response.api_key\n        if not self.__apikey:\n            error_msg = \"API key not found in response\"\n            _LOGGER.error(error_msg)\n            raise AuthenticationError(error_msg)\n        self.__secret_key = set_apikey_response.secret_key\n        if not self.__secret_key:\n            error_msg = \"Secret key not found in response\"\n            _LOGGER.error(error_msg)\n            raise AuthenticationError(error_msg)\n\n        _LOGGER.info(\"Successfully created new API key: ...%s\", self.__apikey[-4:])\n        # Verify if the API key is valid\n        try:\n            await self.validate_apikey()\n            _LOGGER.info(\n                \"Successfully verified new API key: ...%s\", self.__apikey[-4:]\n            )\n        except AuthenticationError as e:\n            _LOGGER.error(\"Created API key failed validation: %s\", e)\n            self.__apikey = None\n            raise\n    except DiagralAPIError as e:\n        error_msg: str = f\"Failed to create API key: {e!s}\"\n        _LOGGER.error(error_msg)\n        raise AuthenticationError(error_msg) from e\n\n    return ApiKeyWithSecret(api_key=self.__apikey, secret_key=self.__secret_key)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.validate_apikey","title":"<code>validate_apikey(apikey=None)</code>  <code>async</code>","text":"<p>Validate the current or provided API key by checking it against the list of valid keys.</p> <p>This method performs the following steps: 1. Checks if the API key is available. If not, logs a warning and raises an AuthenticationError. 2. Ensures that an access token is available by calling the login method if necessary. 3. Sends a GET request to retrieve the list of valid API keys associated with the user's system. 4. Checks if the current or provided API key is in the list of valid keys. 5. Logs a success message if the API key is valid, otherwise raises an AuthenticationError.</p> <p>Parameters:</p> Name Type Description Default <code>apikey</code> <code>str | None</code> <p>The API key to validate. If not provided, the instance's API key is used. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If no API key is provided or if the API key is invalid.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def validate_apikey(self, apikey: str | None = None) -&gt; None:\n    \"\"\"Validate the current or provided API key by checking it against the list of valid keys.\n\n    This method performs the following steps:\n    1. Checks if the API key is available. If not, logs a warning and raises an AuthenticationError.\n    2. Ensures that an access token is available by calling the login method if necessary.\n    3. Sends a GET request to retrieve the list of valid API keys associated with the user's system.\n    4. Checks if the current or provided API key is in the list of valid keys.\n    5. Logs a success message if the API key is valid, otherwise raises an AuthenticationError.\n\n    Args:\n        apikey (str | None, optional): The API key to validate. If not provided, the instance's API key is used. Defaults to None.\n\n    Raises:\n        ConfigurationError: If no API key is provided or if the API key is invalid.\n\n    \"\"\"\n\n    apikey_to_validate: str = apikey or self.__apikey\n\n    if not apikey_to_validate:\n        _LOGGER.warning(\"No API key provided to validate\")\n        raise ConfigurationError(\"No API key provided to validate\")\n\n    if not self.__access_token:\n        await self.login()\n\n    _HEADERS: dict[str, str] = {\n        \"Authorization\": f\"Bearer {self.__access_token}\",\n    }\n    response_data, *_ = await self._request(\n        \"GET\",\n        f\"users/systems/{self.serial_id}/api_keys\",\n        headers=_HEADERS,\n    )\n    validate_apikey_response: ApiKeys = ApiKeys.from_dict(response_data)\n    is_valid = any(\n        key_info.api_key == apikey_to_validate\n        for key_info in validate_apikey_response.api_keys\n    )\n    if is_valid:\n        _LOGGER.info(\"API key successfully validated\")\n    else:\n        raise AuthenticationError(\n            \"API key is invalid or not found in the list of valid keys\"\n        )\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.delete_apikey","title":"<code>delete_apikey(apikey=None)</code>  <code>async</code>","text":"<p>Asynchronously delete the specified or current API key.</p> <p>This method deletes the API key associated with the instance or the provided API key. If the API key is not available, it raises an AuthenticationError. If the access token is not available, it attempts to log in to obtain one. The method then sends a DELETE request to the appropriate endpoint to delete the API key. Upon successful deletion, it logs an informational message and sets the <code>apikey</code> and <code>secret_key</code> attributes to None.</p> <p>Parameters:</p> Name Type Description Default <code>apikey</code> <code>str | None</code> <p>The API key to delete. If not provided, the instance's API key is used. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key is not available.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def delete_apikey(self, apikey: str | None = None) -&gt; None:\n    \"\"\"Asynchronously delete the specified or current API key.\n\n    This method deletes the API key associated with the instance or the provided API key.\n    If the API key is not available, it raises an AuthenticationError. If the access token\n    is not available, it attempts to log in to obtain one. The method then sends a DELETE\n    request to the appropriate endpoint to delete the API key. Upon successful deletion,\n    it logs an informational message and sets the `apikey` and `secret_key` attributes to None.\n\n    Args:\n        apikey (str | None, optional): The API key to delete. If not provided, the instance's API key is used. Defaults to None.\n\n    Raises:\n        AuthenticationError: If the API key is not available.\n\n    \"\"\"\n\n    apikey_to_delete: str = apikey or self.__apikey\n\n    if not apikey_to_delete:\n        raise AuthenticationError(\"An API key is required to delete it\")\n\n    if not self.__access_token:\n        await self.login()\n\n    _HEADERS: dict[str, str] = {\n        \"Authorization\": f\"Bearer {self.__access_token}\",\n    }\n    await self._request(\n        \"DELETE\",\n        f\"users/systems/{self.serial_id}/api_keys/{apikey_to_delete}\",\n        headers=_HEADERS,\n    )\n    _LOGGER.info(\"Successfully deleted API key: ...%s\", apikey_to_delete[-4:])\n\n    if apikey is None:\n        self.__apikey = None\n        self.__secret_key = None\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.try_connection","title":"<code>try_connection(ephemeral=True)</code>  <code>async</code>","text":"<p>Test connection with the Diagral system.</p> <p>This method tests the connection by either using provided API credentials or generating temporary ones. It validates the connection by checking the system status.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeral</code> <code>bool</code> <p>If True, temporary API keys will be deleted after connection test. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>TryConnectResult</code> <code>TryConnectResult</code> <p>Object containing connection test results and optionally API keys if non-ephemeral temporary keys were generated.</p> <p>Raises:</p> Type Description <code>DiagralAPIError</code> <p>If connection attempt fails or system status check fails.</p> Note <p>If API credentials are not provided during client initialization, temporary keys will be generated (if ephemeral) for the connection test. These keys will be: - Deleted after the test if ephemeral=True - Returned in the result if ephemeral=False</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def try_connection(self, ephemeral: bool = True) -&gt; TryConnectResult:\n    \"\"\"Test connection with the Diagral system.\n\n    This method tests the connection by either using provided API credentials or generating\n    temporary ones. It validates the connection by checking the system status.\n\n    Args:\n        ephemeral (bool, optional): If True, temporary API keys will be deleted after\n            connection test. Defaults to True.\n\n    Returns:\n        TryConnectResult: Object containing connection test results and optionally API keys\n            if non-ephemeral temporary keys were generated.\n\n    Raises:\n        DiagralAPIError: If connection attempt fails or system status check fails.\n\n    Note:\n        If API credentials are not provided during client initialization, temporary\n        keys will be generated (if ephemeral) for the connection test. These keys will be:\n        - Deleted after the test if ephemeral=True\n        - Returned in the result if ephemeral=False\n\n    \"\"\"\n\n    result: TryConnectResult = TryConnectResult()\n    api_keys_provided = bool(self.__apikey and self.__secret_key)\n    try:\n        # If API keys are not provided, generate temporary keys\n        if not api_keys_provided:\n            api_key_response: ApiKeyWithSecret = await self.set_apikey()\n\n        # Retrieve system status to validate connection\n        await self.get_system_status()\n        # If connection is successful, clean up temporary keys if requested (ephemeral)\n        if ephemeral and not api_keys_provided:\n            await self.delete_apikey(apikey=self.__apikey)\n        elif not ephemeral and not api_keys_provided:\n            result.keys = api_key_response\n    except DiagralAPIError as e:\n        raise DiagralAPIError(f\"Failed to connect to the system: {e}\") from e\n    result.result = True\n    return result\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_configuration","title":"<code>get_configuration()</code>  <code>async</code>","text":"<p>Asynchronously retrieve the configuration of the Diagral system.</p> <p>This method retrieves the configuration of the Diagral system by sending a GET request to the appropriate endpoint. If the access token is not available, it attempts to log in to obtain one. Upon successful retrieval, it logs an informational message with the configuration details. The retrieved configuration is stored in the self.alarm_configuration attribute, allowing it to be reused within the same session without needing to collect it multiple times.</p> <p>Returns:</p> Name Type Description <code>AlarmConfiguration</code> <code>None</code> <p>The configuration details of the Diagral system.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the access token is not available.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_configuration(self) -&gt; None:\n    \"\"\"Asynchronously retrieve the configuration of the Diagral system.\n\n    This method retrieves the configuration of the Diagral system by sending a GET\n    request to the appropriate endpoint. If the access token is not available, it\n    attempts to log in to obtain one. Upon successful retrieval, it logs an informational\n    message with the configuration details. The retrieved configuration is stored in\n    the self.alarm_configuration attribute, allowing it to be reused within the same\n    session without needing to collect it multiple times.\n\n    Returns:\n        AlarmConfiguration: The configuration details of the Diagral system.\n\n    Raises:\n        AuthenticationError: If the access token is not available.\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get configuration\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"GET\", f\"systems/{self.serial_id}/configurations\", headers=_HEADERS\n    )\n    self.alarm_configuration = AlarmConfiguration.from_dict(response_data)\n    _LOGGER.debug(\n        \"Successfully retrieved configuration: %s\", self.alarm_configuration\n    )\n    return self.alarm_configuration\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_alarm_name","title":"<code>get_alarm_name()</code>  <code>async</code>","text":"<p>Get the name of the alarm from the configuration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the alarm from the configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If unable to retrieve the alarm configuration.</p> Note <p>This method will attempt to fetch the configuration if it hasn't been loaded yet.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_alarm_name(self) -&gt; str:\n    \"\"\"Get the name of the alarm from the configuration.\n\n    Returns:\n        str: The name of the alarm from the configuration.\n\n    Raises:\n        ConfigurationError: If unable to retrieve the alarm configuration.\n\n    Note:\n        This method will attempt to fetch the configuration if it hasn't been loaded yet.\n\n    \"\"\"\n\n    if not self.alarm_configuration:\n        await self.get_configuration()\n\n    if not self.alarm_configuration:\n        raise ConfigurationError(\"Failed to retrieve alarm configuration\")\n\n    return self.alarm_configuration.alarm.name\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_devices_info","title":"<code>get_devices_info()</code>  <code>async</code>","text":"<p>Asynchronously retrieves information about various device types from the alarm configuration.</p> <p>The method retrieve information for each device type (cameras, commands, sensors, sirens, transmitters) from the alarm configuration, and compiles this information into a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>DeviceList</code> <p>A dictionary where the keys are device types and the values are lists of dictionaries</p> <code>DeviceList</code> <p>containing device information (index and label).</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the alarm configuration cannot be retrieved.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_devices_info(self) -&gt; DeviceList:\n    \"\"\"Asynchronously retrieves information about various device types from the alarm configuration.\n\n    The method retrieve information for each device type (cameras, commands, sensors, sirens,\n    transmitters) from the alarm configuration, and compiles this information into a dictionary.\n\n    Returns:\n        dict: A dictionary where the keys are device types and the values are lists of dictionaries\n        containing device information (index and label).\n\n    Raises:\n        ConfigurationError: If the alarm configuration cannot be retrieved.\n\n    \"\"\"\n\n    if not self.alarm_configuration:\n        await self.get_configuration()\n\n    if not self.alarm_configuration:\n        raise ConfigurationError(\"Failed to retrieve alarm configuration\")\n\n    device_types: list[str] = sorted(\n        [\"cameras\", \"commands\", \"sensors\", \"sirens\", \"transmitters\"]\n    )\n    devices_infos = {}\n    for device_type in device_types:\n        _LOGGER.debug(\"Retrieving devices information for %s\", device_type)\n        devices: Any | None = getattr(self.alarm_configuration, device_type, None)\n        if devices is not None:\n            devices_infos[device_type] = [\n                {\"index\": device.index, \"label\": device.label} for device in devices\n            ]\n        else:\n            devices_infos[device_type] = []\n    _LOGGER.debug(\"Successfully retrieved devices information: %s\", devices_infos)\n    return DeviceList.from_dict(devices_infos)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_system_details","title":"<code>get_system_details()</code>  <code>async</code>","text":"<p>Asynchronously retrieves the system details.</p> <p>This method fetches the system details using the provided API key, secret key, and PIN code. It generates the necessary HMAC signature and includes it in the request headers.</p> <p>Returns:</p> Name Type Description <code>SystemDetails</code> <code>SystemDetails</code> <p>An instance of SystemDetails containing the retrieved system information.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_system_details(self) -&gt; SystemDetails:\n    \"\"\"Asynchronously retrieves the system details.\n\n    This method fetches the system details using the provided API key, secret key,\n    and PIN code. It generates the necessary HMAC signature and includes it in the\n    request headers.\n\n    Returns:\n        SystemDetails: An instance of SystemDetails containing the retrieved system information.\n\n    Raises:\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    if not self.__pincode:\n        raise AuthenticationError(\"PIN code required to get system details\")\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-PIN-CODE\": str(self.__pincode),\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"GET\", f\"systems/{self.serial_id}\", headers=_HEADERS\n    )\n    _LOGGER.debug(\"Successfully retrieved system details: %s\", response_data)\n    return SystemDetails.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_system_status","title":"<code>get_system_status()</code>  <code>async</code>","text":"<p>Asynchronously retrieves the system status.</p> <p>This method fetches the current status of the system using the provided API key, secret key, and PIN code. It generates an HMAC signature for authentication and sends a GET request to the system status endpoint.</p> <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the retrieved system status.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_system_status(self) -&gt; SystemStatus:\n    \"\"\"Asynchronously retrieves the system status.\n\n    This method fetches the current status of the system using the provided API key,\n    secret key, and PIN code. It generates an HMAC signature for authentication and\n    sends a GET request to the system status endpoint.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the retrieved system status.\n\n    Raises:\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    if not self.__pincode:\n        raise AuthenticationError(\"PIN code required to get system details\")\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-PIN-CODE\": str(self.__pincode),\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"GET\", f\"systems/{self.serial_id}/status\", headers=_HEADERS\n    )\n    _LOGGER.debug(\"Successfully retrieved system status: %s\", response_data)\n    return SystemStatus.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__system_action","title":"<code>__system_action(action)</code>  <code>async</code>","text":"<p>Perform a system action such as start, stop, presence, partial start 1, or partial start 2.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The action to perform. Must be one of 'start', 'stop', 'presence', 'partial_start_1', or 'partial_start_2'.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after performing the action.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not one of the allowed actions.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is missing.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def __system_action(self, action: str) -&gt; SystemStatus:\n    \"\"\"Perform a system action such as start, stop, presence, partial start 1, or partial start 2.\n\n    Args:\n        action (str): The action to perform. Must be one of 'start', 'stop', 'presence', 'partial_start_1', or 'partial_start_2'.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after performing the action.\n\n    Raises:\n        ConfigurationError: If the action is not one of the allowed actions.\n        AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n    \"\"\"\n\n    if action not in [\n        \"start\",\n        \"stop\",\n        \"presence\",\n        \"partial_start_1\",\n        \"partial_start_2\",\n    ]:\n        raise ConfigurationError(\n            \"Action must be one of 'start', 'stop', 'presence', 'partial_start_1', or 'partial_start_2'\"\n        )\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    if not self.__pincode:\n        raise AuthenticationError(f\"PIN code required to do system action {action}\")\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-PIN-CODE\": str(self.__pincode),\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"POST\", f\"systems/{self.serial_id}/{action}\", headers=_HEADERS\n    )\n    _LOGGER.debug(\n        \"Successfully performed action %s: %s\", action.upper(), response_data\n    )\n    return SystemStatus.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.start_system","title":"<code>start_system()</code>  <code>async</code>","text":"<p>Asynchronously starts the system.</p> <p>This method sends a request to start the system and returns the system status.</p> <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after starting the system.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not one of the allowed actions.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is missing.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def start_system(self) -&gt; SystemStatus:\n    \"\"\"Asynchronously starts the system.\n\n    This method sends a request to start the system and returns the system status.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after starting the system.\n\n    Raises:\n        ConfigurationError: If the action is not one of the allowed actions.\n        AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n    \"\"\"\n\n    return await self.__system_action(\"start\")\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.stop_system","title":"<code>stop_system()</code>  <code>async</code>","text":"<p>Asynchronously stops the system.</p> <p>This method sends a request to stop the system and returns the system status.</p> <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after stopping the system.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not one of the allowed actions.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is missing.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def stop_system(self) -&gt; SystemStatus:\n    \"\"\"Asynchronously stops the system.\n\n    This method sends a request to stop the system and returns the system status.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after stopping the system.\n\n    Raises:\n        ConfigurationError: If the action is not one of the allowed actions.\n        AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n    \"\"\"\n\n    return await self.__system_action(\"stop\")\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.presence","title":"<code>presence()</code>  <code>async</code>","text":"<p>Asynchronously starts the system in presence mode.</p> <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after starting the system in presence mode.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not one of the allowed actions.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is missing.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def presence(self) -&gt; SystemStatus:\n    \"\"\"Asynchronously starts the system in presence mode.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after starting the system in presence mode.\n\n    Raises:\n        ConfigurationError: If the action is not one of the allowed actions.\n        AuthenticationError: If the API key, secret key, or PIN code is missing.\n\n    \"\"\"\n\n    return await self.__system_action(\"presence\")\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.partial_start_system","title":"<code>partial_start_system(id=1)</code>  <code>async</code>","text":"<p>Initiate a partial start of the system.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the partial start. Must be either 1 or 2. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after performing the partial start.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the provided ID is not 1 or 2.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def partial_start_system(self, id: int = 1) -&gt; SystemStatus:  # NOT-TESTED\n    \"\"\"Initiate a partial start of the system.\n\n    Args:\n        id (int, optional): The ID of the partial start. Must be either 1 or 2. Defaults to 1.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after performing the partial start.\n\n    Raises:\n        ConfigurationError: If the provided ID is not 1 or 2.\n\n    \"\"\"\n\n    if id not in [1, 2]:\n        raise ConfigurationError(\"Partial Start Id must be 1 or 2\")\n\n    return await self.__system_action(f\"partial_start_{id}\")\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__action_group_system","title":"<code>__action_group_system(action, groups)</code>  <code>async</code>","text":"<p>Perform an action on a group of systems.</p> <p>This method activates or disables a group of systems based on the provided action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The action to perform. Must be either 'activate_group' or 'disable_group'.</p> required <code>groups</code> <code>list[int]</code> <p>A list of group indices to perform the action on.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after performing the action.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not 'activate_group' or 'disable_group', or if the groups are invalid.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def __action_group_system(\n    self, action: str, groups: list[int]\n) -&gt; SystemStatus:  # TO-TEST\n    \"\"\"Perform an action on a group of systems.\n\n    This method activates or disables a group of systems based on the provided action.\n\n    Args:\n        action (str): The action to perform. Must be either 'activate_group' or 'disable_group'.\n        groups (list[int]): A list of group indices to perform the action on.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after performing the action.\n\n    Raises:\n        ConfigurationError: If the action is not 'activate_group' or 'disable_group', or if the groups are invalid.\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n\n    if action not in [\"activate_group\", \"disable_group\"]:\n        raise ConfigurationError(\n            \"Action must be either 'activate_group' or 'disable_group'\"\n        )\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    if not self.__pincode:\n        raise AuthenticationError(\"PIN code required to get system details\")\n\n    # Get the configuration if it is not already available\n    if not self.alarm_configuration:\n        await self.get_configuration()\n\n    # Check if the groups are valid\n    invalid_groups: list[int] = [\n        group\n        for group in groups\n        if group not in [g.index for g in self.alarm_configuration.groups]\n    ]\n    if invalid_groups:\n        raise ConfigurationError(\n            f\"The following groups do not exist in your system: {invalid_groups}\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-PIN-CODE\": str(self.__pincode),\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    data: dict[str, list[int]] = {\"groups\": groups}\n    response_data, *_ = await self._request(\n        \"POST\",\n        f\"systems/{self.serial_id}/{action}\",\n        headers=_HEADERS,\n        json=data,\n    )\n    _LOGGER.debug(\n        \"Successfully %s %s: %s\", action.replace(\"_\", \" \"), groups, response_data\n    )\n    return SystemStatus.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.activate_group","title":"<code>activate_group(groups)</code>  <code>async</code>","text":"<p>Asynchronously activates a group of systems.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list[int]</code> <p>A list of integers representing the groups to be activated.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after activating the groups.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not one of the allowed actions.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def activate_group(self, groups: list[int]) -&gt; SystemStatus:\n    \"\"\"Asynchronously activates a group of systems.\n\n    Args:\n        groups (list[int]): A list of integers representing the groups to be activated.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after activating the groups.\n\n    Raises:\n        ConfigurationError: If the action is not one of the allowed actions.\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n\n    if not isinstance(groups, list) or not all(\n        isinstance(item, int) for item in groups\n    ):\n        raise ConfigurationError(\"Groups must be a list of integers\")\n\n    return await self.__action_group_system(\"activate_group\", groups)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.disable_group","title":"<code>disable_group(groups)</code>  <code>async</code>","text":"<p>Asynchronously disables a group of systems.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>list[int]</code> <p>A list of integers representing the groups to disable.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after disabling the groups.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not one of the allowed actions.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def disable_group(self, groups: list[int]) -&gt; SystemStatus:\n    \"\"\"Asynchronously disables a group of systems.\n\n    Args:\n        groups (list[int]): A list of integers representing the groups to disable.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after disabling the groups.\n\n    Raises:\n        ConfigurationError: If the action is not one of the allowed actions.\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n\n    if not isinstance(groups, list) or not all(\n        isinstance(item, int) for item in groups\n    ):\n        raise ConfigurationError(\"Groups must be a list of integers\")\n\n    return await self.__action_group_system(\"disable_group\", groups)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__action_product","title":"<code>__action_product(action, type, product_id)</code>  <code>async</code>","text":"<p>Perform an action on a product in the Diagral system.</p> <p>This method enables or disables a product based on the provided action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The action to perform. Must be either 'enable' or 'disable'.</p> required <code>type</code> <code>str</code> <p>The type of product to perform the action on.</p> required <code>product_id</code> <code>int</code> <p>The ID of the product to perform the action on.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after performing the action.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not 'enable' or 'disable', or if the product type is invalid.</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def __action_product(\n    self, action: str, type: str, product_id: int\n) -&gt; SystemStatus:  # NOT-TESTED\n    \"\"\"Perform an action on a product in the Diagral system.\n\n    This method enables or disables a product based on the provided action.\n\n    Args:\n        action (str): The action to perform. Must be either 'enable' or 'disable'.\n        type (str): The type of product to perform the action on.\n        product_id (int): The ID of the product to perform the action on.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after performing the action.\n\n    Raises:\n        ConfigurationError: If the action is not 'enable' or 'disable', or if the product type is invalid.\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n\n    if action not in [\"enable\", \"disable\"]:\n        raise ConfigurationError(\"Action must be either 'enable' or 'disable'\")\n\n    if type not in [\"CENTRAL\", \"SENSOR\", \"COMMAND\", \"ALARM\", \"BOX\", \"PLUG\"]:\n        raise ConfigurationError(\n            \"Product type must be one of 'CENTRAL', 'SENSOR', 'COMMAND', 'ALARM', 'BOX', or 'PLUG'\"\n        )\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    if not self.__pincode:\n        raise AuthenticationError(\"PIN code required to get system details\")\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-PIN-CODE\": str(self.__pincode),\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"POST\",\n        f\"systems/{self.serial_id}/{type}/{product_id}/{action}\",\n        headers=_HEADERS,\n    )\n    return SystemStatus.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.enable_product","title":"<code>enable_product(type, product_id)</code>  <code>async</code>","text":"<p>Asynchronously enables a product in the system.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The type of the product to enable.</p> required <code>product_id</code> <code>int</code> <p>The unique identifier of the product to enable.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after enabling the product.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not 'enable'</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def enable_product(\n    self, type: str, product_id: int\n) -&gt; SystemStatus:  # NOT-TESTED\n    \"\"\"Asynchronously enables a product in the system.\n\n    Args:\n        type (str): The type of the product to enable.\n        product_id (int): The unique identifier of the product to enable.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after enabling the product.\n\n    Raises:\n        ConfigurationError: If the action is not 'enable'\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n    return await self.__action_product(\n        action=\"enable\", type=type, product_id=product_id\n    )\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.disable_product","title":"<code>disable_product(type, product_id)</code>  <code>async</code>","text":"<p>Asynchronously enables a product in the system.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The type of the product to enable.</p> required <code>product_id</code> <code>int</code> <p>The unique identifier of the product to enable.</p> required <p>Returns:</p> Name Type Description <code>SystemStatus</code> <code>SystemStatus</code> <p>An instance of SystemStatus containing the system status after disabling the product.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not 'disable'</p> <code>AuthenticationError</code> <p>If the API key, secret key, or PIN code is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def disable_product(\n    self, type: str, product_id: int\n) -&gt; SystemStatus:  # NOT-TESTED\n    \"\"\"Asynchronously enables a product in the system.\n\n    Args:\n        type (str): The type of the product to enable.\n        product_id (int): The unique identifier of the product to enable.\n\n    Returns:\n        SystemStatus: An instance of SystemStatus containing the system status after disabling the product.\n\n    Raises:\n        ConfigurationError: If the action is not 'disable'\n        AuthenticationError: If the API key, secret key, or PIN code is not provided.\n\n    \"\"\"\n    return await self.__action_product(\n        action=\"disable\", type=type, product_id=product_id\n    )\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_anomalies","title":"<code>get_anomalies()</code>  <code>async</code>","text":"<p>Asynchronously retrieves anomalies for the system.</p> <p>This method fetches the anomalies associated with the system identified by the serial ID. It requires valid API key and secret key for authentication.</p> <p>Returns:</p> Type Description <code>Anomalies | dict</code> <p>Anomalies | dict: An instance of the Anomalies class populated with the data retrieved from the API, or an empty dictionary if no anomalies are found.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key or secret key is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_anomalies(self) -&gt; Anomalies | dict:\n    \"\"\"Asynchronously retrieves anomalies for the system.\n\n    This method fetches the anomalies associated with the system identified by the serial ID. It requires valid API key and secret key for authentication.\n\n    Returns:\n        Anomalies | dict: An instance of the Anomalies class populated with the data retrieved from the API, or an empty dictionary if no anomalies are found.\n\n    Raises:\n        AuthenticationError: If the API key or secret key is not provided.\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    try:\n        response_data, *_ = await self._request(\n            \"GET\",\n            f\"systems/{self.serial_id}/anomalies\",\n            headers=_HEADERS,\n        )\n    except DiagralAPIError as e:\n        if e.status_code == 404 and \"No anomalies found\" in e.message:\n            _LOGGER.info(\"No anomalies found for the system\")\n            return {}\n    return Anomalies.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.delete_anomalies","title":"<code>delete_anomalies(anomaly_id)</code>  <code>async</code>","text":"<p>Asynchronously delete the list of anomalies.</p> <p>This method is currently not implemented.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method is not yet implemented.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def delete_anomalies(self, anomaly_id: int) -&gt; None:  # NOT-IMPLEMENTED\n    \"\"\"Asynchronously delete the list of anomalies.\n\n    This method is currently not implemented.\n\n    Raises:\n        NotImplementedError: This method is not yet implemented.\n\n    \"\"\"\n    raise NotImplementedError(\"Method not yet implemented\")\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_automatism_rudes","title":"<code>get_automatism_rudes()</code>  <code>async</code>","text":"<p>Asynchronously retrieves the automatism Rudes for the system.</p> <p>This method fetches the Rudes data for the system identified by the serial ID. It requires valid API and secret keys for authentication.</p> <p>Returns:</p> Name Type Description <code>Rudes</code> <code>Rudes</code> <p>An instance of the Rudes class populated with the data from the response.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key or secret key is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_automatism_rudes(self) -&gt; Rudes:  # NOT-TESTED\n    \"\"\"Asynchronously retrieves the automatism Rudes for the system.\n\n    This method fetches the Rudes data for the system identified by the serial ID.\n    It requires valid API and secret keys for authentication.\n\n    Returns:\n        Rudes: An instance of the Rudes class populated with the data from the response.\n\n    Raises:\n        AuthenticationError: If the API key or secret key is not provided.\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"GET\",\n        f\"systems/{self.serial_id}/rudes\",\n        headers=_HEADERS,\n    )\n    return Rudes.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.set_automatism_action","title":"<code>set_automatism_action(canal, action)</code>  <code>async</code>","text":"<p>Set the automatism action.</p> <p>This method is currently not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>canal</code> <code>str</code> <p>The canal for the automatism action.</p> required <code>action</code> <code>str</code> <p>The action to be set for the automatism.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, as this method is not yet implemented.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def set_automatism_action(\n    self, canal: str, action: str\n) -&gt; None:  # NOT-IMPLEMENTED\n    \"\"\"Set the automatism action.\n\n    This method is currently not implemented.\n\n    Args:\n        canal (str): The canal for the automatism action.\n        action (str): The action to be set for the automatism.\n\n    Raises:\n        NotImplementedError: Always, as this method is not yet implemented.\n\n    \"\"\"\n    raise NotImplementedError(\"Method not yet implemented\")\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.get_webhook","title":"<code>get_webhook()</code>  <code>async</code>","text":"<p>Retrieve the webhook subscription details for the system.</p> <p>Returns:</p> Name Type Description <code>Webhook</code> <code>Webhook</code> <p>An instance of the Webhook class containing the subscription details.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key or secret key is not provided.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def get_webhook(self) -&gt; Webhook:\n    \"\"\"Retrieve the webhook subscription details for the system.\n\n    Returns:\n        Webhook: An instance of the Webhook class containing the subscription details.\n\n    Raises:\n        AuthenticationError: If the API key or secret key is not provided.\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"GET\",\n        f\"webhooks/{self.serial_id}/subscription\",\n        headers=_HEADERS,\n    )\n    return Webhook.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__webhook_action_create_update","title":"<code>__webhook_action_create_update(action, webhook_url, subscribe_to_anomaly=False, subscribe_to_alert=False, subscribe_to_state=False)</code>  <code>async</code>","text":"<p>Create or update a webhook subscription.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>The action to perform, either 'register' or 'update'.</p> required <code>webhook_url</code> <code>str</code> <p>The URL of the webhook to register or update.</p> required <code>subscribe_to_anomaly</code> <code>bool</code> <p>Whether to subscribe to anomaly notifications. Defaults to False.</p> <code>False</code> <code>subscribe_to_alert</code> <code>bool</code> <p>Whether to subscribe to alert notifications. Defaults to False.</p> <code>False</code> <code>subscribe_to_state</code> <code>bool</code> <p>Whether to subscribe to state notifications. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Webhook | None</code> <p>Webhook | None: The created or updated Webhook object, or None if registration is skipped.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If the action is not 'register' or 'update'.</p> <code>AuthenticationError</code> <p>If the API key or secret key is missing.</p> <code>ValidationError</code> <p>If the webhook URL is invalid or if the subscription already exists.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def __webhook_action_create_update(\n    self,\n    action: str,\n    webhook_url: str,\n    subscribe_to_anomaly: bool = False,\n    subscribe_to_alert: bool = False,\n    subscribe_to_state: bool = False,\n) -&gt; Webhook | None:\n    \"\"\"Create or update a webhook subscription.\n\n    Args:\n        action (str): The action to perform, either 'register' or 'update'.\n        webhook_url (str): The URL of the webhook to register or update.\n        subscribe_to_anomaly (bool, optional): Whether to subscribe to anomaly notifications. Defaults to False.\n        subscribe_to_alert (bool, optional): Whether to subscribe to alert notifications. Defaults to False.\n        subscribe_to_state (bool, optional): Whether to subscribe to state notifications. Defaults to False.\n\n    Returns:\n        Webhook | None: The created or updated Webhook object, or None if registration is skipped.\n\n    Raises:\n        ConfigurationError: If the action is not 'register' or 'update'.\n        AuthenticationError: If the API key or secret key is missing.\n        ValidationError: If the webhook URL is invalid or if the subscription already exists.\n\n    \"\"\"\n    if action not in [\"register\", \"update\"]:\n        raise ConfigurationError(\"Action must be either 'register' or 'update'\")\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    if action == \"register\" and not any(\n        [subscribe_to_anomaly, subscribe_to_alert, subscribe_to_state]\n    ):\n        _LOGGER.warning(\"No subscriptions selected, skipping webhook registration\")\n        return None\n\n    if not re.match(r\"^https?://\", webhook_url):\n        raise ValidationError(\n            \"Invalid webhook URL. Must start with http:// or https://\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    data = {\n        \"webhook_url\": webhook_url,\n        \"subscribe_to_anomaly\": subscribe_to_anomaly,\n        \"subscribe_to_alert\": subscribe_to_alert,\n        \"subscribe_to_state\": subscribe_to_state,\n    }\n    method = \"POST\" if action == \"register\" else \"PUT\"\n    try:\n        response_data, *_ = await self._request(\n            method,\n            f\"webhooks/{self.serial_id}/subscription\",\n            headers=_HEADERS,\n            json=data,\n        )\n    except DiagralAPIError as e:\n        if \"Subscription already exists\" in str(e):\n            raise DiagralAPIError(\n                \"Webhook subscription already exists. Please use the 'update' action to modify it.\"\n            ) from e\n        if \"There is no subscription for\" in str(e):\n            raise DiagralAPIError(\n                \"No subscription found for the specified serial ID\"\n            ) from e\n    return Webhook.from_dict(response_data)\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.register_webhook","title":"<code>register_webhook(webhook_url, subscribe_to_anomaly=False, subscribe_to_alert=False, subscribe_to_state=False)</code>  <code>async</code>","text":"<p>Register a webhook with the specified URL and subscription options.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_url</code> <code>str</code> <p>The URL to which the webhook will send data.</p> required <code>subscribe_to_anomaly</code> <code>bool</code> <p>If True, subscribe to anomaly events. Defaults to False.</p> <code>False</code> <code>subscribe_to_alert</code> <code>bool</code> <p>If True, subscribe to alert events. Defaults to False.</p> <code>False</code> <code>subscribe_to_state</code> <code>bool</code> <p>If True, subscribe to state events. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Webhook | None</code> <p>Webhook | None: The registered Webhook object if successful, otherwise None.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def register_webhook(\n    self,\n    webhook_url: str,\n    subscribe_to_anomaly: bool = False,\n    subscribe_to_alert: bool = False,\n    subscribe_to_state: bool = False,\n) -&gt; Webhook | None:\n    \"\"\"Register a webhook with the specified URL and subscription options.\n\n    Args:\n        webhook_url (str): The URL to which the webhook will send data.\n        subscribe_to_anomaly (bool, optional): If True, subscribe to anomaly events. Defaults to False.\n        subscribe_to_alert (bool, optional): If True, subscribe to alert events. Defaults to False.\n        subscribe_to_state (bool, optional): If True, subscribe to state events. Defaults to False.\n\n    Returns:\n        Webhook | None: The registered Webhook object if successful, otherwise None.\n\n    \"\"\"\n    return await self.__webhook_action_create_update(\n        \"register\",\n        webhook_url,\n        subscribe_to_anomaly,\n        subscribe_to_alert,\n        subscribe_to_state,\n    )\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.update_webhook","title":"<code>update_webhook(webhook_url, subscribe_to_anomaly=False, subscribe_to_alert=False, subscribe_to_state=False)</code>  <code>async</code>","text":"<p>Update the webhook configuration with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_url</code> <code>str</code> <p>The URL of the webhook to update.</p> required <code>subscribe_to_anomaly</code> <code>bool</code> <p>Whether to subscribe to anomaly notifications. Defaults to False.</p> <code>False</code> <code>subscribe_to_alert</code> <code>bool</code> <p>Whether to subscribe to alert notifications. Defaults to False.</p> <code>False</code> <code>subscribe_to_state</code> <code>bool</code> <p>Whether to subscribe to state notifications. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Webhook | None</code> <p>Webhook | None: The registered Webhook object if successful, otherwise None.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def update_webhook(\n    self,\n    webhook_url: str,\n    subscribe_to_anomaly: bool = False,\n    subscribe_to_alert: bool = False,\n    subscribe_to_state: bool = False,\n) -&gt; Webhook | None:\n    \"\"\"Update the webhook configuration with the specified parameters.\n\n    Args:\n        webhook_url (str): The URL of the webhook to update.\n        subscribe_to_anomaly (bool, optional): Whether to subscribe to anomaly notifications. Defaults to False.\n        subscribe_to_alert (bool, optional): Whether to subscribe to alert notifications. Defaults to False.\n        subscribe_to_state (bool, optional): Whether to subscribe to state notifications. Defaults to False.\n\n    Returns:\n        Webhook | None: The registered Webhook object if successful, otherwise None.\n\n    \"\"\"\n    return await self.__webhook_action_create_update(\n        \"update\",\n        webhook_url,\n        subscribe_to_anomaly,\n        subscribe_to_alert,\n        subscribe_to_state,\n    )\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.delete_webhook","title":"<code>delete_webhook()</code>  <code>async</code>","text":"<p>Asynchronously deletes the webhook subscription for the current system.</p> <p>Raises:</p> Type Description <code>AuthenticationError</code> <p>If the API key or secret key is not provided.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>async def delete_webhook(self) -&gt; None:\n    \"\"\"Asynchronously deletes the webhook subscription for the current system.\n\n    Raises:\n        AuthenticationError: If the API key or secret key is not provided.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    if not self.__apikey or not self.__secret_key:\n        raise AuthenticationError(\n            \"API key and secret key required to get system details\"\n        )\n\n    _TIMESTAMP = str(int(time.time()))\n    _HMAC: str = generate_hmac_signature(\n        timestamp=_TIMESTAMP,\n        serial_id=self.serial_id,\n        api_key=self.__apikey,\n        secret_key=self.__secret_key,\n    )\n\n    _HEADERS: dict[str, str] = {\n        \"X-HMAC\": _HMAC,\n        \"X-TIMESTAMP\": _TIMESTAMP,\n        \"X-APIKEY\": self.__apikey,\n    }\n    response_data, *_ = await self._request(\n        \"DELETE\",\n        f\"webhooks/{self.serial_id}/subscription\",\n        headers=_HEADERS,\n    )\n</code></pre>"},{"location":"api/#pydiagral.api.DiagralAPI.__is_valid_email","title":"<code>__is_valid_email(email)</code>  <code>staticmethod</code>","text":"<p>Validate the format of an email address.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email address to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the email is valid, False otherwise.</p> Source code in <code>src/pydiagral/api.py</code> <pre><code>@staticmethod\ndef __is_valid_email(email: str) -&gt; bool:\n    \"\"\"Validate the format of an email address.\n\n    Args:\n        email (str): The email address to validate.\n\n    Returns:\n        bool: True if the email is valid, False otherwise.\n\n    \"\"\"\n    email_regex = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n    return re.match(email_regex, email) is not None\n</code></pre>"},{"location":"exceptions/","title":"Exceptions Reference","text":""},{"location":"exceptions/#exceptions-reference","title":"Exceptions Reference","text":""},{"location":"exceptions/#pydiagral.exceptions","title":"<code>pydiagral.exceptions</code>","text":"<p>Module defining custom exceptions for the Diagral API.</p>"},{"location":"exceptions/#pydiagral.exceptions.DiagralAPIError","title":"<code>DiagralAPIError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Diagral API errors.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class DiagralAPIError(Exception):\n    \"\"\"Base exception for Diagral API errors.\"\"\"\n\n    def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n        \"\"\"Initialize the DiagralAPIError.\n\n        :param message: The error message.\n        :param status_code: The status code of the error, if any.\n        \"\"\"\n        self.message: str = message\n        self.status_code: int | None = status_code\n        super().__init__(self.message)\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.DiagralAPIError.__init__","title":"<code>__init__(message, status_code=None)</code>","text":"<p>Initialize the DiagralAPIError.</p> <p>:param message: The error message. :param status_code: The status code of the error, if any.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n    \"\"\"Initialize the DiagralAPIError.\n\n    :param message: The error message.\n    :param status_code: The status code of the error, if any.\n    \"\"\"\n    self.message: str = message\n    self.status_code: int | None = status_code\n    super().__init__(self.message)\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>DiagralAPIError</code></p> <p>Raised when configuration is invalid.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class ConfigurationError(DiagralAPIError):\n    \"\"\"Raised when configuration is invalid.\"\"\"\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.SessionError","title":"<code>SessionError</code>","text":"<p>               Bases: <code>DiagralAPIError</code></p> <p>Raised when session is invalid.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class SessionError(DiagralAPIError):\n    \"\"\"Raised when session is invalid.\"\"\"\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.AuthenticationError","title":"<code>AuthenticationError</code>","text":"<p>               Bases: <code>DiagralAPIError</code></p> <p>Raised when authentication fails.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class AuthenticationError(DiagralAPIError):\n    \"\"\"Raised when authentication fails.\"\"\"\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>DiagralAPIError</code></p> <p>Raised when validation fails.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class ValidationError(DiagralAPIError):\n    \"\"\"Raised when validation fails.\"\"\"\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>DiagralAPIError</code></p> <p>Raised when server returns 5xx error.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class ServerError(DiagralAPIError):\n    \"\"\"Raised when server returns 5xx error.\"\"\"\n</code></pre>"},{"location":"exceptions/#pydiagral.exceptions.ClientError","title":"<code>ClientError</code>","text":"<p>               Bases: <code>DiagralAPIError</code></p> <p>Raised when client returns error.</p> Source code in <code>src/pydiagral/exceptions.py</code> <pre><code>class ClientError(DiagralAPIError):\n    \"\"\"Raised when client returns error.\"\"\"\n</code></pre>"},{"location":"models/","title":"Models Reference","text":""},{"location":"models/#models-reference","title":"Models Reference","text":""},{"location":"models/#pydiagral.models","title":"<code>pydiagral.models</code>","text":"<p>Module containing data models for interacting with the Diagral API.</p> <p>The models include representations for login responses, API key creation and validation, and other related data structures.</p>"},{"location":"models/#pydiagral.models.CamelCaseModel","title":"<code>CamelCaseModel</code>","text":"<p>CamelCaseModel is a base class for models that need to convert between snake_case and camelCase keys.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Convert the model instance to a dictionary with camelCase keys.</p> <code>_from_dict_recursive</code> <p>dict, target_cls: type[T]) -&gt; T: Recursively create an instance of the target class from a dictionary.</p> <code>from_dict</code> <p>type[T], data: dict) -&gt; T: Create an instance of the model from a dictionary.</p> <code>snake_to_camel</code> <p>str) -&gt; str: Convert a snake_case string to camelCase.</p> <code>camel_to_snake</code> <p>str) -&gt; str: Convert a camelCase string to snake_case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @dataclass\n... class ExampleModel(CamelCaseModel):\n...     first_name: str\n...     last_name: str\n...\n&gt;&gt;&gt; example = ExampleModel(first_name=\"Luke\", last_name=\"Skywalker\")\n&gt;&gt;&gt; example_dict = example.to_dict()\n&gt;&gt;&gt; print(example_dict)\n{'firstName': 'Luke', 'lastName': 'Skywalker'}\n&gt;&gt;&gt; new_example = ExampleModel.from_dict(example_dict)\n&gt;&gt;&gt; print(new_example)\nExampleModel(first_name='Luke', last_name='Skywalker')\n</code></pre> Source code in <code>src/pydiagral/models.py</code> <pre><code>class CamelCaseModel:\n    \"\"\"CamelCaseModel is a base class for models that need to convert between snake_case and camelCase keys.\n\n    Methods:\n        to_dict() -&gt; dict:\n            Convert the model instance to a dictionary with camelCase keys.\n        _from_dict_recursive(cls, data: dict, target_cls: type[T]) -&gt; T:\n            Recursively create an instance of the target class from a dictionary.\n        from_dict(cls: type[T], data: dict) -&gt; T:\n            Create an instance of the model from a dictionary.\n        snake_to_camel(string: str) -&gt; str:\n            Convert a snake_case string to camelCase.\n        camel_to_snake(string: str) -&gt; str:\n            Convert a camelCase string to snake_case.\n\n    Examples:\n        &gt;&gt;&gt; @dataclass\n        ... class ExampleModel(CamelCaseModel):\n        ...     first_name: str\n        ...     last_name: str\n        ...\n        &gt;&gt;&gt; example = ExampleModel(first_name=\"Luke\", last_name=\"Skywalker\")\n        &gt;&gt;&gt; example_dict = example.to_dict()\n        &gt;&gt;&gt; print(example_dict)\n        {'firstName': 'Luke', 'lastName': 'Skywalker'}\n        &gt;&gt;&gt; new_example = ExampleModel.from_dict(example_dict)\n        &gt;&gt;&gt; print(new_example)\n        ExampleModel(first_name='Luke', last_name='Skywalker')\n\n    \"\"\"\n\n    # Type variable for the class itself\n    T = TypeVar(\"T\", bound=\"CamelCaseModel\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the instance attributes to a dictionary, transforming attribute names.\n\n        from snake_case to camelCase and handling nested CamelCaseModel instances.\n\n        Returns:\n            dict: A dictionary representation of the instance with camelCase keys.\n\n        Example:\n            &gt;&gt;&gt; class ExampleModel(CamelCaseModel):\n            ...     first_name: str\n            ...     last_name: str\n            ...\n            &gt;&gt;&gt; example = ExampleModel(first_name=\"Luke\", last_name=\"Skywalker\")\n            &gt;&gt;&gt; example.to_dict()\n            {'firstName': 'Luke', 'lastName': 'Skywalker'}\n\n        \"\"\"\n\n        result = {}\n        for k, v in self.__dict__.items():\n            if v is not None:\n                if isinstance(v, CamelCaseModel):\n                    v = v.to_dict()\n                elif isinstance(v, list) and v and isinstance(v[0], CamelCaseModel):\n                    v = [item.to_dict() for item in v]\n                key = getattr(self.__class__, k).metadata.get(\n                    \"alias\", self.snake_to_camel(k)\n                )\n                result[key] = v\n        return result\n\n    @classmethod\n    def _from_dict_recursive(cls: type[T], data: dict, target_cls: type[T]) -&gt; T:\n        \"\"\"Recursively converts a dictionary to an instance of the specified target class.\n\n        This method handles nested dictionaries and lists, converting them to the appropriate\n        types as specified by the target class's type hints. It also supports optional fields\n        by handling `Union` types and removing `None` from the type hints.\n\n        Args:\n            cls (type[T]): The class that this method is a part of.\n            data (dict): The dictionary to convert.\n            target_cls (type[T]): The target class to convert the dictionary to.\n\n        Returns:\n            T: An instance of the target class populated with the data from the dictionary.\n\n        Raises:\n            TypeError: If the target class cannot be instantiated with the provided data.\n\n        Notes:\n            - The method assumes that the target class and its nested classes (if any) are\n              annotated with type hints.\n            - The method uses snake_case to camelCase conversion for dictionary keys to match\n              the field names in the target class.\n            - The method logs detailed debug information about the conversion process.\n\n        \"\"\"\n\n        logger.debug(\"Converting data: %s to %s\", data, target_cls)\n\n        logger.debug(\"Extracted target_cls: %s\", target_cls)\n        if get_origin(target_cls) is Union:\n            # Extract the real type by removing None\n            target_cls = next(t for t in get_args(target_cls) if t is not type(None))\n            logger.debug(\"Extracted target_cls: %s\", target_cls)\n\n        init_values = {}\n        fields_dict = {field.name: field for field in fields(target_cls)}\n        for field_name, field_type in get_type_hints(target_cls).items():\n            field = fields_dict.get(field_name)\n            logger.debug(\"Field Metadata: %s\", field.metadata if field else {})\n            # alias = cls.snake_to_camel(field_name) # Old version who don't support field with underscore and without alias\n            alias = field.metadata.get(\"alias\", field_name)\n            logger.debug(\n                \"Processing field: %s (alias: %s, type: %s)\",\n                field_name,\n                alias,\n                field_type,\n            )\n\n            logger.debug(\"Extracted field_type: %s\", field_type)\n            if get_origin(field_type) is types.UnionType:\n                # Extract the real type by removing None\n                field_type = next(\n                    t for t in get_args(field_type) if t is not type(None)\n                )\n                logger.debug(\"Extracted field_type: %s\", field_type)\n\n            logger.debug(\"Checking if alias %s is in data: %s\", alias, data)\n            if any(alias.lower() == key.lower() for key in data):\n                alias = next(key for key in data if alias.lower() == key.lower())\n                value = data[alias]\n                logger.debug(\"Found value for %s: %s\", alias, value)\n\n                if (\n                    isinstance(value, dict)\n                    and isinstance(field_type, type)\n                    and issubclass(field_type, CamelCaseModel)\n                ):\n                    logger.debug(\n                        \"Recursively converting nested dict for field: %s\", field_name\n                    )\n                    init_values[field_name] = cls._from_dict_recursive(\n                        value, field_type\n                    )\n                elif isinstance(value, list) and get_origin(field_type) is list:\n                    item_type = get_args(field_type)[0]\n                    logger.debug(\n                        \"Recursively converting list for field: %s with item type: %s\",\n                        field_name,\n                        item_type,\n                    )\n                    init_values[field_name] = [\n                        cls._from_dict_recursive(item, item_type)\n                        if isinstance(item, dict)\n                        else item\n                        for item in value\n                    ]\n                else:\n                    init_values[field_name] = value\n            else:\n                init_values[field_name] = None\n                logger.debug(\"No value found for %s, setting to None\", alias)\n\n        logger.debug(\"Initialized values for %s: %s\", target_cls, init_values)\n        return target_cls(**init_values)\n\n    @classmethod\n    def from_dict(cls: type[T], data: dict) -&gt; T:\n        \"\"\"Create an instance of the class from a dictionary.\n\n        Args:\n            cls (type[T]): The class type to instantiate.\n            data (dict): The dictionary containing the data to populate the instance.\n\n        Returns:\n            T: An instance of the class populated with the data from the dictionary.\n\n        Example:\n            &gt;&gt;&gt; data = {\"diagral_id\": 123, \"user_id\": 456, \"access_token\": \"abc123\"}\n            &gt;&gt;&gt; login_response = LoginResponse.from_dict(data)\n            &gt;&gt;&gt; login_response.diagral_id\n            123\n            &gt;&gt;&gt; login_response.user_id\n            456\n            &gt;&gt;&gt; login_response.access_token\n            'abc123'\n\n        \"\"\"\n\n        return cls._from_dict_recursive(data, cls)\n\n    @staticmethod\n    def snake_to_camel(string: str) -&gt; str:\n        \"\"\"Convert a snake_case string to camelCase.\n\n        Args:\n            string (str): The snake_case string to be converted.\n\n        Returns:\n            str: The converted camelCase string.\n\n        Example:\n            &gt;&gt;&gt; snake_to_camel(\"example_string\")\n            'exampleString'\n\n        \"\"\"\n\n        components = string.split(\"_\")\n        return components[0] + \"\".join(x.title() for x in components[1:])\n\n    @staticmethod\n    def camel_to_snake(string: str) -&gt; str:\n        \"\"\"Convert a CamelCase string to snake_case.\n\n        Args:\n            string (str): The CamelCase string to be converted.\n\n        Returns:\n            str: The converted snake_case string.\n\n        Example:\n            &gt;&gt;&gt; camel_to_snake(\"CamelCaseString\")\n            'camel_case_string'\n\n        \"\"\"\n\n        # Replace capital letters with _ followed by the lowercase letter\n        s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", string)\n        # Handle cases where multiple capitals are together\n        s2 = re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1)\n        return s2.lower()\n</code></pre>"},{"location":"models/#pydiagral.models.CamelCaseModel.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the instance attributes to a dictionary, transforming attribute names.</p> <p>from snake_case to camelCase and handling nested CamelCaseModel instances.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representation of the instance with camelCase keys.</p> Example <p>class ExampleModel(CamelCaseModel): ...     first_name: str ...     last_name: str ... example = ExampleModel(first_name=\"Luke\", last_name=\"Skywalker\") example.to_dict() {'firstName': 'Luke', 'lastName': 'Skywalker'}</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the instance attributes to a dictionary, transforming attribute names.\n\n    from snake_case to camelCase and handling nested CamelCaseModel instances.\n\n    Returns:\n        dict: A dictionary representation of the instance with camelCase keys.\n\n    Example:\n        &gt;&gt;&gt; class ExampleModel(CamelCaseModel):\n        ...     first_name: str\n        ...     last_name: str\n        ...\n        &gt;&gt;&gt; example = ExampleModel(first_name=\"Luke\", last_name=\"Skywalker\")\n        &gt;&gt;&gt; example.to_dict()\n        {'firstName': 'Luke', 'lastName': 'Skywalker'}\n\n    \"\"\"\n\n    result = {}\n    for k, v in self.__dict__.items():\n        if v is not None:\n            if isinstance(v, CamelCaseModel):\n                v = v.to_dict()\n            elif isinstance(v, list) and v and isinstance(v[0], CamelCaseModel):\n                v = [item.to_dict() for item in v]\n            key = getattr(self.__class__, k).metadata.get(\n                \"alias\", self.snake_to_camel(k)\n            )\n            result[key] = v\n    return result\n</code></pre>"},{"location":"models/#pydiagral.models.CamelCaseModel._from_dict_recursive","title":"<code>_from_dict_recursive(data, target_cls)</code>  <code>classmethod</code>","text":"<p>Recursively converts a dictionary to an instance of the specified target class.</p> <p>This method handles nested dictionaries and lists, converting them to the appropriate types as specified by the target class's type hints. It also supports optional fields by handling <code>Union</code> types and removing <code>None</code> from the type hints.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[T]</code> <p>The class that this method is a part of.</p> required <code>data</code> <code>dict</code> <p>The dictionary to convert.</p> required <code>target_cls</code> <code>type[T]</code> <p>The target class to convert the dictionary to.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the target class populated with the data from the dictionary.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the target class cannot be instantiated with the provided data.</p> Notes <ul> <li>The method assumes that the target class and its nested classes (if any) are   annotated with type hints.</li> <li>The method uses snake_case to camelCase conversion for dictionary keys to match   the field names in the target class.</li> <li>The method logs detailed debug information about the conversion process.</li> </ul> Source code in <code>src/pydiagral/models.py</code> <pre><code>@classmethod\ndef _from_dict_recursive(cls: type[T], data: dict, target_cls: type[T]) -&gt; T:\n    \"\"\"Recursively converts a dictionary to an instance of the specified target class.\n\n    This method handles nested dictionaries and lists, converting them to the appropriate\n    types as specified by the target class's type hints. It also supports optional fields\n    by handling `Union` types and removing `None` from the type hints.\n\n    Args:\n        cls (type[T]): The class that this method is a part of.\n        data (dict): The dictionary to convert.\n        target_cls (type[T]): The target class to convert the dictionary to.\n\n    Returns:\n        T: An instance of the target class populated with the data from the dictionary.\n\n    Raises:\n        TypeError: If the target class cannot be instantiated with the provided data.\n\n    Notes:\n        - The method assumes that the target class and its nested classes (if any) are\n          annotated with type hints.\n        - The method uses snake_case to camelCase conversion for dictionary keys to match\n          the field names in the target class.\n        - The method logs detailed debug information about the conversion process.\n\n    \"\"\"\n\n    logger.debug(\"Converting data: %s to %s\", data, target_cls)\n\n    logger.debug(\"Extracted target_cls: %s\", target_cls)\n    if get_origin(target_cls) is Union:\n        # Extract the real type by removing None\n        target_cls = next(t for t in get_args(target_cls) if t is not type(None))\n        logger.debug(\"Extracted target_cls: %s\", target_cls)\n\n    init_values = {}\n    fields_dict = {field.name: field for field in fields(target_cls)}\n    for field_name, field_type in get_type_hints(target_cls).items():\n        field = fields_dict.get(field_name)\n        logger.debug(\"Field Metadata: %s\", field.metadata if field else {})\n        # alias = cls.snake_to_camel(field_name) # Old version who don't support field with underscore and without alias\n        alias = field.metadata.get(\"alias\", field_name)\n        logger.debug(\n            \"Processing field: %s (alias: %s, type: %s)\",\n            field_name,\n            alias,\n            field_type,\n        )\n\n        logger.debug(\"Extracted field_type: %s\", field_type)\n        if get_origin(field_type) is types.UnionType:\n            # Extract the real type by removing None\n            field_type = next(\n                t for t in get_args(field_type) if t is not type(None)\n            )\n            logger.debug(\"Extracted field_type: %s\", field_type)\n\n        logger.debug(\"Checking if alias %s is in data: %s\", alias, data)\n        if any(alias.lower() == key.lower() for key in data):\n            alias = next(key for key in data if alias.lower() == key.lower())\n            value = data[alias]\n            logger.debug(\"Found value for %s: %s\", alias, value)\n\n            if (\n                isinstance(value, dict)\n                and isinstance(field_type, type)\n                and issubclass(field_type, CamelCaseModel)\n            ):\n                logger.debug(\n                    \"Recursively converting nested dict for field: %s\", field_name\n                )\n                init_values[field_name] = cls._from_dict_recursive(\n                    value, field_type\n                )\n            elif isinstance(value, list) and get_origin(field_type) is list:\n                item_type = get_args(field_type)[0]\n                logger.debug(\n                    \"Recursively converting list for field: %s with item type: %s\",\n                    field_name,\n                    item_type,\n                )\n                init_values[field_name] = [\n                    cls._from_dict_recursive(item, item_type)\n                    if isinstance(item, dict)\n                    else item\n                    for item in value\n                ]\n            else:\n                init_values[field_name] = value\n        else:\n            init_values[field_name] = None\n            logger.debug(\"No value found for %s, setting to None\", alias)\n\n    logger.debug(\"Initialized values for %s: %s\", target_cls, init_values)\n    return target_cls(**init_values)\n</code></pre>"},{"location":"models/#pydiagral.models.CamelCaseModel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of the class from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[T]</code> <p>The class type to instantiate.</p> required <code>data</code> <code>dict</code> <p>The dictionary containing the data to populate the instance.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the class populated with the data from the dictionary.</p> Example <p>data = {\"diagral_id\": 123, \"user_id\": 456, \"access_token\": \"abc123\"} login_response = LoginResponse.from_dict(data) login_response.diagral_id 123 login_response.user_id 456 login_response.access_token 'abc123'</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@classmethod\ndef from_dict(cls: type[T], data: dict) -&gt; T:\n    \"\"\"Create an instance of the class from a dictionary.\n\n    Args:\n        cls (type[T]): The class type to instantiate.\n        data (dict): The dictionary containing the data to populate the instance.\n\n    Returns:\n        T: An instance of the class populated with the data from the dictionary.\n\n    Example:\n        &gt;&gt;&gt; data = {\"diagral_id\": 123, \"user_id\": 456, \"access_token\": \"abc123\"}\n        &gt;&gt;&gt; login_response = LoginResponse.from_dict(data)\n        &gt;&gt;&gt; login_response.diagral_id\n        123\n        &gt;&gt;&gt; login_response.user_id\n        456\n        &gt;&gt;&gt; login_response.access_token\n        'abc123'\n\n    \"\"\"\n\n    return cls._from_dict_recursive(data, cls)\n</code></pre>"},{"location":"models/#pydiagral.models.CamelCaseModel.snake_to_camel","title":"<code>snake_to_camel(string)</code>  <code>staticmethod</code>","text":"<p>Convert a snake_case string to camelCase.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The snake_case string to be converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted camelCase string.</p> Example <p>snake_to_camel(\"example_string\") 'exampleString'</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@staticmethod\ndef snake_to_camel(string: str) -&gt; str:\n    \"\"\"Convert a snake_case string to camelCase.\n\n    Args:\n        string (str): The snake_case string to be converted.\n\n    Returns:\n        str: The converted camelCase string.\n\n    Example:\n        &gt;&gt;&gt; snake_to_camel(\"example_string\")\n        'exampleString'\n\n    \"\"\"\n\n    components = string.split(\"_\")\n    return components[0] + \"\".join(x.title() for x in components[1:])\n</code></pre>"},{"location":"models/#pydiagral.models.CamelCaseModel.camel_to_snake","title":"<code>camel_to_snake(string)</code>  <code>staticmethod</code>","text":"<p>Convert a CamelCase string to snake_case.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The CamelCase string to be converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted snake_case string.</p> Example <p>camel_to_snake(\"CamelCaseString\") 'camel_case_string'</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@staticmethod\ndef camel_to_snake(string: str) -&gt; str:\n    \"\"\"Convert a CamelCase string to snake_case.\n\n    Args:\n        string (str): The CamelCase string to be converted.\n\n    Returns:\n        str: The converted snake_case string.\n\n    Example:\n        &gt;&gt;&gt; camel_to_snake(\"CamelCaseString\")\n        'camel_case_string'\n\n    \"\"\"\n\n    # Replace capital letters with _ followed by the lowercase letter\n    s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", string)\n    # Handle cases where multiple capitals are together\n    s2 = re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1)\n    return s2.lower()\n</code></pre>"},{"location":"models/#pydiagral.models.LoginResponse","title":"<code>LoginResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>LoginResponse model represents the response received after a successful login.</p> <p>Attributes:</p> Name Type Description <code>access_token</code> <code>str</code> <p>The access token provided for authentication.</p> Example <p>response = LoginResponse( ...     access_token=\"abc123\", ... ) print(response.access_token) abc123</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass LoginResponse(CamelCaseModel):\n    \"\"\"LoginResponse model represents the response received after a successful login.\n\n    Attributes:\n        access_token (str): The access token provided for authentication.\n\n    Example:\n        &gt;&gt;&gt; response = LoginResponse(\n        ...     access_token=\"abc123\",\n        ... )\n        &gt;&gt;&gt; print(response.access_token)\n        abc123\n\n    \"\"\"\n\n    access_token: str\n</code></pre>"},{"location":"models/#pydiagral.models.ApiKeyWithSecret","title":"<code>ApiKeyWithSecret</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>ApiKeyWithSecret is a model that represents an API key and its corresponding secret key.</p> <p>Attributes:</p> Name Type Description <code>api_key</code> <code>str</code> <p>The API key, which must be a non-empty string.</p> <code>secret_key</code> <code>str</code> <p>The secret key associated with the API key, which must also be a non-empty string.</p> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Post-initialization processing to validate the API key and secret key.</p> Example <p>api_key_with_secret = ApiKeyWithSecret(api_key=\"your_api_key\", secret_key=\"your_secret_key\") print(api_key_with_secret.api_key) your_api_key print(api_key_with_secret.secret_key) your_secret_key</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass ApiKeyWithSecret(CamelCaseModel):\n    \"\"\"ApiKeyWithSecret is a model that represents an API key and its corresponding secret key.\n\n    Attributes:\n        api_key (str): The API key, which must be a non-empty string.\n        secret_key (str): The secret key associated with the API key, which must also be a non-empty string.\n\n    Methods:\n        __post_init__(): Post-initialization processing to validate the API key and secret key.\n\n    Example:\n        &gt;&gt;&gt; api_key_with_secret = ApiKeyWithSecret(api_key=\"your_api_key\", secret_key=\"your_secret_key\")\n        &gt;&gt;&gt; print(api_key_with_secret.api_key)\n        your_api_key\n        &gt;&gt;&gt; print(api_key_with_secret.secret_key)\n        your_secret_key\n\n    \"\"\"\n\n    api_key: str\n    secret_key: str\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate API key and secret key.\"\"\"\n        if not self.api_key or not isinstance(self.api_key, str):\n            raise ValueError(\"api_key must be a non-empty string\")\n        if not self.secret_key or not isinstance(self.secret_key, str):\n            raise ValueError(\"secret_key must be a non-empty string\")\n</code></pre>"},{"location":"models/#pydiagral.models.ApiKeyWithSecret.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization processing to validate API key and secret key.</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Post-initialization processing to validate API key and secret key.\"\"\"\n    if not self.api_key or not isinstance(self.api_key, str):\n        raise ValueError(\"api_key must be a non-empty string\")\n    if not self.secret_key or not isinstance(self.secret_key, str):\n        raise ValueError(\"secret_key must be a non-empty string\")\n</code></pre>"},{"location":"models/#pydiagral.models.ApiKey","title":"<code>ApiKey</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>Represents an API key model.</p> <p>Attributes:</p> Name Type Description <code>api_key</code> <code>str</code> <p>The API key as a string.</p> Example <p>api_key = ApiKey(api_key=\"your_api_key\") print(api_key.api_key) your_api_key</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass ApiKey(CamelCaseModel):\n    \"\"\"Represents an API key model.\n\n    Attributes:\n        api_key (str): The API key as a string.\n\n    Example:\n        &gt;&gt;&gt; api_key = ApiKey(api_key=\"your_api_key\")\n        &gt;&gt;&gt; print(api_key.api_key)\n        your_api_key\n\n    \"\"\"\n\n    api_key: str\n</code></pre>"},{"location":"models/#pydiagral.models.ApiKeys","title":"<code>ApiKeys</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>ApiKeys model to represent a collection of API keys.</p> <p>Attributes:</p> Name Type Description <code>api_keys</code> <code>list[ApiKey]</code> <p>A list of ApiKey instances.</p> <p>Methods:</p> Name Description <code>from_dict</code> <p>dict) -&gt; ApiKeys: Class method to create an instance of ApiKeys from a dictionary.</p> Example <p>data = {\"api_keys\": [{\"api_key\": \"key1\"}, {\"api_key\": \"key2\"}]} api_keys = ApiKeys.from_dict(data) print(api_keys.api_keys) [ApiKey(api_key='key1'), ApiKey(api_key='key2')]</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass ApiKeys(CamelCaseModel):\n    \"\"\"ApiKeys model to represent a collection of API keys.\n\n    Attributes:\n        api_keys (list[ApiKey]): A list of ApiKey instances.\n\n    Methods:\n        from_dict(data: dict) -&gt; ApiKeys:\n            Class method to create an instance of ApiKeys from a dictionary.\n\n    Example:\n        &gt;&gt;&gt; data = {\"api_keys\": [{\"api_key\": \"key1\"}, {\"api_key\": \"key2\"}]}\n        &gt;&gt;&gt; api_keys = ApiKeys.from_dict(data)\n        &gt;&gt;&gt; print(api_keys.api_keys)\n        [ApiKey(api_key='key1'), ApiKey(api_key='key2')]\n\n    \"\"\"\n\n    api_keys: list[ApiKey]\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; ApiKeys:\n        \"\"\"Create an instance of ApiKeys from a dictionary.\"\"\"\n\n        return cls(\n            api_keys=[ApiKey(**key_info) for key_info in data.get(\"api_keys\", [])]\n        )\n</code></pre>"},{"location":"models/#pydiagral.models.ApiKeys.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of ApiKeys from a dictionary.</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; ApiKeys:\n    \"\"\"Create an instance of ApiKeys from a dictionary.\"\"\"\n\n    return cls(\n        api_keys=[ApiKey(**key_info) for key_info in data.get(\"api_keys\", [])]\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.TryConnectResult","title":"<code>TryConnectResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>A class representing the result of an API connection attempt.</p> <p>This class is used to store the result of an API connection attempt and the associated API keys if the connection was successful.</p> <p>Attributes:</p> Name Type Description <code>result</code> <code>bool | None</code> <p>Whether the connection attempt was successful. Defaults to False.</p> <code>keys</code> <code>ApiKeyWithSecret | None</code> <p>The API keys associated with the successful connection. Defaults to None.</p> Example <p>result = TryConnectResult(result=True, keys=api_key_obj) print(result.result) True print(result.keys) ApiKeyWithSecret(api_key='abc123', api_secret='xyz789')</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass TryConnectResult(CamelCaseModel):\n    \"\"\"A class representing the result of an API connection attempt.\n\n    This class is used to store the result of an API connection attempt\n    and the associated API keys if the connection was successful.\n\n    Attributes:\n        result (bool | None): Whether the connection attempt was successful. Defaults to False.\n        keys (ApiKeyWithSecret | None): The API keys associated with the successful connection. Defaults to None.\n\n    Example:\n        &gt;&gt;&gt; result = TryConnectResult(result=True, keys=api_key_obj)\n        &gt;&gt;&gt; print(result.result)\n        True\n        &gt;&gt;&gt; print(result.keys)\n        ApiKeyWithSecret(api_key='abc123', api_secret='xyz789')\n\n    \"\"\"\n\n    result: bool | None = False\n    keys: ApiKeyWithSecret | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.FirmwareModel","title":"<code>FirmwareModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>FirmwareModel represents the firmware details of a device.</p> <p>Attributes:</p> Name Type Description <code>box</code> <code>str | None</code> <p>The firmware version of the box, aliased as \"BOX\".</p> <code>central</code> <code>str | None</code> <p>The firmware version of the central unit, aliased as \"CENTRAL\".</p> <code>centralradio</code> <code>str | None</code> <p>The firmware version of the central radio unit, aliased as \"CENTRALRADIO\".</p> Example <p>firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\") print(firmware.box) '1.0.0' print(firmware.central) '2.0.0' print(firmware.centralradio) '3.0.0'</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass FirmwareModel(CamelCaseModel):\n    \"\"\"FirmwareModel represents the firmware details of a device.\n\n    Attributes:\n        box (str | None): The firmware version of the box, aliased as \"BOX\".\n        central (str | None): The firmware version of the central unit, aliased as \"CENTRAL\".\n        centralradio (str | None): The firmware version of the central radio unit, aliased as \"CENTRALRADIO\".\n\n    Example:\n        &gt;&gt;&gt; firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\")\n        &gt;&gt;&gt; print(firmware.box)\n        '1.0.0'\n        &gt;&gt;&gt; print(firmware.central)\n        '2.0.0'\n        &gt;&gt;&gt; print(firmware.centralradio)\n        '3.0.0'\n\n    \"\"\"\n\n    box: str | None = field(default=None, metadata={\"alias\": \"BOX\"})\n    central: str | None = field(default=None, metadata={\"alias\": \"CENTRAL\"})\n    centralradio: str | None = field(default=None, metadata={\"alias\": \"CENTRALRADIO\"})\n</code></pre>"},{"location":"models/#pydiagral.models.CentralPlugModel","title":"<code>CentralPlugModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>CentralPlugModel represents the central plug device.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>The name of the central plug device.</p> <code>serial</code> <code>str | None</code> <p>The serial number of the central plug device.</p> <code>vendor</code> <code>str | None</code> <p>The vendor of the central plug device.</p> <code>firmwares</code> <code>FirmwareModel | None</code> <p>The firmware information of the central plug device.</p> Example <p>firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\") central_plug = CentralPlugModel( ...     name=\"Central Plug 1\", ...     serial=\"123456789\", ...     vendor=\"VendorName\", ...     firmwares=firmware ... ) print(central_plug.name) Central Plug 1 print(central_plug.serial) 123456789 print(central_plug.vendor) VendorName print(central_plug.firmwares.box) 1.0.0</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass CentralPlugModel(CamelCaseModel):\n    \"\"\"CentralPlugModel represents the central plug device.\n\n    Attributes:\n        name (str | None): The name of the central plug device.\n        serial (str | None): The serial number of the central plug device.\n        vendor (str | None): The vendor of the central plug device.\n        firmwares (FirmwareModel | None): The firmware information of the central plug device.\n\n    Example:\n        &gt;&gt;&gt; firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\")\n        &gt;&gt;&gt; central_plug = CentralPlugModel(\n        ...     name=\"Central Plug 1\",\n        ...     serial=\"123456789\",\n        ...     vendor=\"VendorName\",\n        ...     firmwares=firmware\n        ... )\n        &gt;&gt;&gt; print(central_plug.name)\n        Central Plug 1\n        &gt;&gt;&gt; print(central_plug.serial)\n        123456789\n        &gt;&gt;&gt; print(central_plug.vendor)\n        VendorName\n        &gt;&gt;&gt; print(central_plug.firmwares.box)\n        1.0.0\n\n    \"\"\"\n\n    name: str | None = None\n    serial: str | None = None\n    vendor: str | None = None\n    firmwares: FirmwareModel | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.Group","title":"<code>Group</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>Represents a Group model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>The name of the group. Defaults to None.</p> <code>index</code> <code>int | None</code> <p>The index of the group. Defaults to None.</p> <code>input_delay</code> <code>int | None</code> <p>The input delay of the group, aliased as 'inputDelay'. Defaults to None.</p> <code>output_delay</code> <code>int | None</code> <p>The output delay of the group, aliased as 'outputDelay'. Defaults to None.</p> Example <p>group = Group(name=\"Group A\", index=1, input_delay=10, output_delay=20) print(group.name) Group A print(group.index) 1 print(group.input_delay) 10 print(group.output_delay) 20</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass Group(CamelCaseModel):\n    \"\"\"Represents a Group model.\n\n    Attributes:\n        name (str | None): The name of the group. Defaults to None.\n        index (int | None): The index of the group. Defaults to None.\n        input_delay (int | None): The input delay of the group, aliased as 'inputDelay'. Defaults to None.\n        output_delay (int | None): The output delay of the group, aliased as 'outputDelay'. Defaults to None.\n\n    Example:\n        &gt;&gt;&gt; group = Group(name=\"Group A\", index=1, input_delay=10, output_delay=20)\n        &gt;&gt;&gt; print(group.name)\n        Group A\n        &gt;&gt;&gt; print(group.index)\n        1\n        &gt;&gt;&gt; print(group.input_delay)\n        10\n        &gt;&gt;&gt; print(group.output_delay)\n        20\n\n    \"\"\"\n\n    name: str | None = None\n    index: int | None = None\n    input_delay: int | None = field(default=None, metadata={\"alias\": \"inputDelay\"})\n    output_delay: int | None = field(default=None, metadata={\"alias\": \"outputDelay\"})\n</code></pre>"},{"location":"models/#pydiagral.models.ConfAnomaliesModel","title":"<code>ConfAnomaliesModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>ConfAnomaliesModel is a data model that represents various configuration anomalies in a system.</p> <p>Attributes:</p> Name Type Description <code>radio_alert</code> <code>bool | None</code> <p>Indicates if there is a radio alert. Alias: \"radioAlert\".</p> <code>power_supply_alert</code> <code>bool | None</code> <p>Indicates if there is a power supply alert. Alias: \"powerSupplyAlert\".</p> <code>autoprotection_mechanical_alert</code> <code>bool | None</code> <p>Indicates if there is an autoprotection mechanical alert. Alias: \"autoprotectionMechanicalAlert\".</p> <code>loop_alert</code> <code>bool | None</code> <p>Indicates if there is a loop alert. Alias: \"loopAlert\".</p> <code>mask_alert</code> <code>bool | None</code> <p>Indicates if there is a mask alert. Alias: \"maskAlert\".</p> <code>sensor_alert</code> <code>bool | None</code> <p>Indicates if there is a sensor alert. Alias: \"sensorAlert\".</p> <code>media_gsm_alert</code> <code>bool | None</code> <p>Indicates if there is a GSM media alert. Alias: \"mediaGSMAlert\".</p> <code>media_rtc_alert</code> <code>bool | None</code> <p>Indicates if there is an RTC media alert. Alias: \"mediaRTCAlert\".</p> <code>media_adsl_alert</code> <code>bool | None</code> <p>Indicates if there is an ADSL media alert. Alias: \"mediaADSLAlert\".</p> <code>out_of_order_alert</code> <code>bool | None</code> <p>Indicates if there is an out of order alert. Alias: \"outOfOrderAlert\".</p> <code>main_power_supply_alert</code> <code>bool | None</code> <p>Indicates if there is a main power supply alert. Alias: \"mainPowerSupplyAlert\".</p> <code>secondary_power_supply_alert</code> <code>bool | None</code> <p>Indicates if there is a secondary power supply alert. Alias: \"secondaryPowerSupplyAlert\".</p> <code>default_media_alert</code> <code>bool | None</code> <p>Indicates if there is a default media alert. Alias: \"defaultMediaAlert\".</p> <code>autoprotection_wired_alert</code> <code>bool | None</code> <p>Indicates if there is an autoprotection wired alert. Alias: \"autoprotectionWiredAlert\".</p> Example <p>anomalies = ConfAnomaliesModel( ...     radio_alert=True, ...     power_supply_alert=False, ...     autoprotection_mechanical_alert=True, ...     loop_alert=False, ...     mask_alert=True, ...     sensor_alert=False, ...     media_gsm_alert=True, ...     media_rtc_alert=False, ...     media_adsl_alert=True, ...     out_of_order_alert=False, ...     main_power_supply_alert=True, ...     secondary_power_supply_alert=False, ...     default_media_alert=True, ...     autoprotection_wired_alert=False ... ) print(anomalies.radio_alert) True print(anomalies.power_supply_alert) False</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass ConfAnomaliesModel(CamelCaseModel):\n    \"\"\"ConfAnomaliesModel is a data model that represents various configuration anomalies in a system.\n\n    Attributes:\n        radio_alert (bool | None): Indicates if there is a radio alert. Alias: \"radioAlert\".\n        power_supply_alert (bool | None): Indicates if there is a power supply alert. Alias: \"powerSupplyAlert\".\n        autoprotection_mechanical_alert (bool | None): Indicates if there is an autoprotection mechanical alert. Alias: \"autoprotectionMechanicalAlert\".\n        loop_alert (bool | None): Indicates if there is a loop alert. Alias: \"loopAlert\".\n        mask_alert (bool | None): Indicates if there is a mask alert. Alias: \"maskAlert\".\n        sensor_alert (bool | None): Indicates if there is a sensor alert. Alias: \"sensorAlert\".\n        media_gsm_alert (bool | None): Indicates if there is a GSM media alert. Alias: \"mediaGSMAlert\".\n        media_rtc_alert (bool | None): Indicates if there is an RTC media alert. Alias: \"mediaRTCAlert\".\n        media_adsl_alert (bool | None): Indicates if there is an ADSL media alert. Alias: \"mediaADSLAlert\".\n        out_of_order_alert (bool | None): Indicates if there is an out of order alert. Alias: \"outOfOrderAlert\".\n        main_power_supply_alert (bool | None): Indicates if there is a main power supply alert. Alias: \"mainPowerSupplyAlert\".\n        secondary_power_supply_alert (bool | None): Indicates if there is a secondary power supply alert. Alias: \"secondaryPowerSupplyAlert\".\n        default_media_alert (bool | None): Indicates if there is a default media alert. Alias: \"defaultMediaAlert\".\n        autoprotection_wired_alert (bool | None): Indicates if there is an autoprotection wired alert. Alias: \"autoprotectionWiredAlert\".\n\n    Example:\n        &gt;&gt;&gt; anomalies = ConfAnomaliesModel(\n        ...     radio_alert=True,\n        ...     power_supply_alert=False,\n        ...     autoprotection_mechanical_alert=True,\n        ...     loop_alert=False,\n        ...     mask_alert=True,\n        ...     sensor_alert=False,\n        ...     media_gsm_alert=True,\n        ...     media_rtc_alert=False,\n        ...     media_adsl_alert=True,\n        ...     out_of_order_alert=False,\n        ...     main_power_supply_alert=True,\n        ...     secondary_power_supply_alert=False,\n        ...     default_media_alert=True,\n        ...     autoprotection_wired_alert=False\n        ... )\n        &gt;&gt;&gt; print(anomalies.radio_alert)\n        True\n        &gt;&gt;&gt; print(anomalies.power_supply_alert)\n        False\n\n    \"\"\"\n\n    radio_alert: bool | None = field(default=None, metadata={\"alias\": \"radioAlert\"})\n    power_supply_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"powerSupplyAlert\"}\n    )\n    autoprotection_mechanical_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"autoprotectionMechanicalAlert\"}\n    )\n    loop_alert: bool | None = field(default=None, metadata={\"alias\": \"loopAlert\"})\n    mask_alert: bool | None = field(default=None, metadata={\"alias\": \"maskAlert\"})\n    sensor_alert: bool | None = field(default=None, metadata={\"alias\": \"sensorAlert\"})\n    media_gsm_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"mediaGSMAlert\"}\n    )\n    media_rtc_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"mediaRTCAlert\"}\n    )\n    media_adsl_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"mediaADSLAlert\"}\n    )\n    out_of_order_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"outOfOrderAlert\"}\n    )\n    main_power_supply_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"mainPowerSupplyAlert\"}\n    )\n    secondary_power_supply_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"secondaryPowerSupplyAlert\"}\n    )\n    default_media_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"defaultMediaAlert\"}\n    )\n    autoprotection_wired_alert: bool | None = field(\n        default=None, metadata={\"alias\": \"autoprotectionWiredAlert\"}\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.SensorModel","title":"<code>SensorModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>SensorModel represents the data structure for a sensor.</p> <p>Attributes:</p> Name Type Description <code>uid</code> <code>str | None</code> <p>Unique identifier for the sensor.</p> <code>type</code> <code>int | None</code> <p>Type of the sensor.</p> <code>gamme</code> <code>int | None</code> <p>Range or category of the sensor.</p> <code>group</code> <code>int | None</code> <p>Group to which the sensor belongs.</p> <code>index</code> <code>int | None</code> <p>Index of the sensor.</p> <code>label</code> <code>str | None</code> <p>Label or name of the sensor.</p> <code>serial</code> <code>str | None</code> <p>Serial number of the sensor.</p> <code>is_video</code> <code>bool | None</code> <p>Indicates if the sensor is a video sensor (alias: isVideo).</p> <code>ref_code</code> <code>str | None</code> <p>Reference code of the sensor (alias: refCode).</p> <code>subtype</code> <code>int | None</code> <p>Subtype of the sensor.</p> <code>anomalies</code> <code>ConfAnomaliesModel | None</code> <p>Configuration anomalies associated with the sensor.</p> <code>inhibited</code> <code>bool | None</code> <p>Indicates if the sensor is inhibited.</p> <code>can_inhibit</code> <code>bool | None</code> <p>Indicates if the sensor can be inhibited (alias: canInhibit).</p> Example <p>anomalies = ConfAnomaliesModel(radio_alert=True) sensor = SensorModel( ...     uid=\"12345\", ...     type=1, ...     gamme=2, ...     group=3, ...     index=4, ...     label=\"Sensor 1\", ...     serial=\"SN12345\", ...     is_video=True, ...     ref_code=\"RC123\", ...     subtype=5, ...     anomalies=anomalies, ...     inhibited=False, ...     can_inhibit=True ... ) print(sensor.uid) 12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass SensorModel(CamelCaseModel):\n    \"\"\"SensorModel represents the data structure for a sensor.\n\n    Attributes:\n        uid (str | None): Unique identifier for the sensor.\n        type (int | None): Type of the sensor.\n        gamme (int | None): Range or category of the sensor.\n        group (int | None): Group to which the sensor belongs.\n        index (int | None): Index of the sensor.\n        label (str | None): Label or name of the sensor.\n        serial (str | None): Serial number of the sensor.\n        is_video (bool | None): Indicates if the sensor is a video sensor (alias: isVideo).\n        ref_code (str | None): Reference code of the sensor (alias: refCode).\n        subtype (int | None): Subtype of the sensor.\n        anomalies (ConfAnomaliesModel | None): Configuration anomalies associated with the sensor.\n        inhibited (bool | None): Indicates if the sensor is inhibited.\n        can_inhibit (bool | None): Indicates if the sensor can be inhibited (alias: canInhibit).\n\n    Example:\n        &gt;&gt;&gt; anomalies = ConfAnomaliesModel(radio_alert=True)\n        &gt;&gt;&gt; sensor = SensorModel(\n        ...     uid=\"12345\",\n        ...     type=1,\n        ...     gamme=2,\n        ...     group=3,\n        ...     index=4,\n        ...     label=\"Sensor 1\",\n        ...     serial=\"SN12345\",\n        ...     is_video=True,\n        ...     ref_code=\"RC123\",\n        ...     subtype=5,\n        ...     anomalies=anomalies,\n        ...     inhibited=False,\n        ...     can_inhibit=True\n        ... )\n        &gt;&gt;&gt; print(sensor.uid)\n        12345\n\n    \"\"\"\n\n    uid: str | None = None\n    type: int | None = None\n    gamme: int | None = None\n    group: int | None = None\n    index: int | None = None\n    label: str | None = None\n    serial: str | None = None\n    is_video: bool | None = field(default=None, metadata={\"alias\": \"isVideo\"})\n    ref_code: str | None = field(default=None, metadata={\"alias\": \"refCode\"})\n    subtype: int | None = None\n    anomalies: ConfAnomaliesModel | None = None\n    inhibited: bool | None = None\n    can_inhibit: bool | None = field(default=None, metadata={\"alias\": \"canInhibit\"})\n</code></pre>"},{"location":"models/#pydiagral.models.Cameras","title":"<code>Cameras</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SensorModel</code></p> <p>Cameras model representing a sensor with an installation date, inheriting from SensorModel.</p> <p>Attributes:</p> Name Type Description <code>installation_date</code> <code>datetime | None</code> <p>The date when the camera was installed. Defaults to None. This attribute is aliased as 'installationDate' in metadata.</p> Example <p>camera = Cameras( ...     uid=\"12345\", ...     type=1, ...     gamme=2, ...     group=3, ...     index=4, ...     label=\"Camera 1\", ...     serial=\"SN12345\", ...     is_video=True, ...     ref_code=\"RC123\", ...     subtype=5, ...     anomalies=None, ...     inhibited=False, ...     can_inhibit=True, ...     installation_date=datetime(2023, 10, 1) ... ) print(camera.installation_date) 2023-10-01 00:00:00</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass Cameras(SensorModel):\n    \"\"\"Cameras model representing a sensor with an installation date, inheriting from SensorModel.\n\n    Attributes:\n        installation_date (datetime | None): The date when the camera was installed.\n            Defaults to None. This attribute is aliased as 'installationDate' in metadata.\n\n    Example:\n        &gt;&gt;&gt; camera = Cameras(\n        ...     uid=\"12345\",\n        ...     type=1,\n        ...     gamme=2,\n        ...     group=3,\n        ...     index=4,\n        ...     label=\"Camera 1\",\n        ...     serial=\"SN12345\",\n        ...     is_video=True,\n        ...     ref_code=\"RC123\",\n        ...     subtype=5,\n        ...     anomalies=None,\n        ...     inhibited=False,\n        ...     can_inhibit=True,\n        ...     installation_date=datetime(2023, 10, 1)\n        ... )\n        &gt;&gt;&gt; print(camera.installation_date)\n        2023-10-01 00:00:00\n\n    \"\"\"\n\n    installation_date: datetime | None = field(\n        default=None, metadata={\"alias\": \"installationDate\"}\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.TransceiverModel","title":"<code>TransceiverModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SensorModel</code></p> <p>TransceiverModel represents a model for a transceiver device, inheriting from SensorModel.</p> <p>Attributes:</p> Name Type Description <code>firmwares</code> <code>FirmwareModel | None</code> <p>An optional attribute that holds the firmware information associated with the transceiver.</p> Example <p>firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\") transceiver = TransceiverModel( ...     uid=\"12345\", ...     type=1, ...     gamme=2, ...     group=3, ...     index=4, ...     label=\"Transceiver 1\", ...     serial=\"SN12345\", ...     is_video=True, ...     ref_code=\"RC123\", ...     subtype=5, ...     anomalies=None, ...     inhibited=False, ...     can_inhibit=True, ...     firmwares=firmware ... ) print(transceiver.uid) 12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass TransceiverModel(SensorModel):\n    \"\"\"TransceiverModel represents a model for a transceiver device, inheriting from SensorModel.\n\n    Attributes:\n        firmwares (FirmwareModel | None): An optional attribute that holds the firmware information associated with the transceiver.\n\n    Example:\n        &gt;&gt;&gt; firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\")\n        &gt;&gt;&gt; transceiver = TransceiverModel(\n        ...     uid=\"12345\",\n        ...     type=1,\n        ...     gamme=2,\n        ...     group=3,\n        ...     index=4,\n        ...     label=\"Transceiver 1\",\n        ...     serial=\"SN12345\",\n        ...     is_video=True,\n        ...     ref_code=\"RC123\",\n        ...     subtype=5,\n        ...     anomalies=None,\n        ...     inhibited=False,\n        ...     can_inhibit=True,\n        ...     firmwares=firmware\n        ... )\n        &gt;&gt;&gt; print(transceiver.uid)\n        12345\n\n    \"\"\"\n\n    firmwares: FirmwareModel | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.TransmitterModel","title":"<code>TransmitterModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SensorModel</code></p> <p>TransmitterModel represents a model for a transmitter device, inheriting from SensorModel.</p> <p>Attributes:</p> Name Type Description <code>firmwares</code> <code>FirmwareModel | None</code> <p>The firmware associated with the transmitter, if any.</p> <code>is_plug</code> <code>bool | None</code> <p>Indicates whether the transmitter is a plug, with metadata alias \"isPlug\".</p> Example <p>firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\") transmitter = TransmitterModel( ...     uid=\"12345\", ...     type=1, ...     gamme=2, ...     group=3, ...     index=4, ...     label=\"Transmitter 1\", ...     serial=\"SN12345\", ...     is_video=True, ...     ref_code=\"RC123\", ...     subtype=5, ...     anomalies=None, ...     inhibited=False, ...     can_inhibit=True, ...     firmwares=firmware, ...     is_plug=True ... ) print(transmitter.uid) 12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass TransmitterModel(SensorModel):\n    \"\"\"TransmitterModel represents a model for a transmitter device, inheriting from SensorModel.\n\n    Attributes:\n        firmwares (FirmwareModel | None): The firmware associated with the transmitter, if any.\n        is_plug (bool | None): Indicates whether the transmitter is a plug, with metadata alias \"isPlug\".\n\n    Example:\n        &gt;&gt;&gt; firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\")\n        &gt;&gt;&gt; transmitter = TransmitterModel(\n        ...     uid=\"12345\",\n        ...     type=1,\n        ...     gamme=2,\n        ...     group=3,\n        ...     index=4,\n        ...     label=\"Transmitter 1\",\n        ...     serial=\"SN12345\",\n        ...     is_video=True,\n        ...     ref_code=\"RC123\",\n        ...     subtype=5,\n        ...     anomalies=None,\n        ...     inhibited=False,\n        ...     can_inhibit=True,\n        ...     firmwares=firmware,\n        ...     is_plug=True\n        ... )\n        &gt;&gt;&gt; print(transmitter.uid)\n        12345\n\n    \"\"\"\n\n    firmwares: FirmwareModel | None = None\n    is_plug: bool | None = field(default=None, metadata={\"alias\": \"isPlug\"})\n</code></pre>"},{"location":"models/#pydiagral.models.CentralInformation","title":"<code>CentralInformation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>CentralInformation model represents the central unit's configuration and status information.</p> <p>Attributes:</p> Name Type Description <code>has_plug</code> <code>bool | None</code> <p>Indicates if the central unit has a plug. Alias: \"hasPlug\".</p> <code>plug_gsm</code> <code>bool | None</code> <p>Indicates if the central unit has a GSM plug. Alias: \"plugGSM\".</p> <code>plug_rtc</code> <code>bool | None</code> <p>Indicates if the central unit has an RTC plug. Alias: \"plugRTC\".</p> <code>plug_adsl</code> <code>bool | None</code> <p>Indicates if the central unit has an ADSL plug. Alias: \"plugADSL\".</p> <code>anomalies</code> <code>ConfAnomaliesModel | None</code> <p>Represents the configuration anomalies of the central unit.</p> <code>firmwares</code> <code>FirmwareModel | None</code> <p>Represents the firmware information of the central unit.</p> <code>relay_card</code> <code>bool | None</code> <p>Indicates if the central unit has a relay card. Alias: \"relayCard\".</p> <code>can_inhibit</code> <code>bool | None</code> <p>Indicates if the central unit can be inhibited. Alias: \"canInhibit\".</p> <code>parameter_gsm_saved</code> <code>bool | None</code> <p>Indicates if the GSM parameters are saved. Alias: \"parameterGsmSaved\".</p> Example <p>anomalies = ConfAnomaliesModel(radio_alert=True) firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\") central_info = CentralInformation( ...     has_plug=True, ...     plug_gsm=True, ...     plug_rtc=False, ...     plug_adsl=True, ...     anomalies=anomalies, ...     firmwares=firmware, ...     relay_card=True, ...     can_inhibit=True, ...     parameter_gsm_saved=False ... ) print(central_info.has_plug) True</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass CentralInformation(CamelCaseModel):\n    \"\"\"CentralInformation model represents the central unit's configuration and status information.\n\n    Attributes:\n        has_plug (bool | None): Indicates if the central unit has a plug. Alias: \"hasPlug\".\n        plug_gsm (bool | None): Indicates if the central unit has a GSM plug. Alias: \"plugGSM\".\n        plug_rtc (bool | None): Indicates if the central unit has an RTC plug. Alias: \"plugRTC\".\n        plug_adsl (bool | None): Indicates if the central unit has an ADSL plug. Alias: \"plugADSL\".\n        anomalies (ConfAnomaliesModel | None): Represents the configuration anomalies of the central unit.\n        firmwares (FirmwareModel | None): Represents the firmware information of the central unit.\n        relay_card (bool | None): Indicates if the central unit has a relay card. Alias: \"relayCard\".\n        can_inhibit (bool | None): Indicates if the central unit can be inhibited. Alias: \"canInhibit\".\n        parameter_gsm_saved (bool | None): Indicates if the GSM parameters are saved. Alias: \"parameterGsmSaved\".\n\n    Example:\n        &gt;&gt;&gt; anomalies = ConfAnomaliesModel(radio_alert=True)\n        &gt;&gt;&gt; firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\")\n        &gt;&gt;&gt; central_info = CentralInformation(\n        ...     has_plug=True,\n        ...     plug_gsm=True,\n        ...     plug_rtc=False,\n        ...     plug_adsl=True,\n        ...     anomalies=anomalies,\n        ...     firmwares=firmware,\n        ...     relay_card=True,\n        ...     can_inhibit=True,\n        ...     parameter_gsm_saved=False\n        ... )\n        &gt;&gt;&gt; print(central_info.has_plug)\n        True\n\n    \"\"\"\n\n    has_plug: bool | None = field(default=None, metadata={\"alias\": \"hasPlug\"})\n    plug_gsm: bool | None = field(default=None, metadata={\"alias\": \"plugGSM\"})\n    plug_rtc: bool | None = field(default=None, metadata={\"alias\": \"plugRTC\"})\n    plug_adsl: bool | None = field(default=None, metadata={\"alias\": \"plugADSL\"})\n    anomalies: ConfAnomaliesModel | None = None\n    firmwares: FirmwareModel | None = None\n    relay_card: bool | None = field(default=None, metadata={\"alias\": \"relayCard\"})\n    can_inhibit: bool | None = field(default=None, metadata={\"alias\": \"canInhibit\"})\n    parameter_gsm_saved: bool | None = field(\n        default=None, metadata={\"alias\": \"parameterGsmSaved\"}\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.BoxModel","title":"<code>BoxModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>BoxModel represents a model for a box with various attributes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>The name of the box. Defaults to None.</p> <code>serial</code> <code>str | None</code> <p>The serial number of the box. Defaults to None.</p> <code>vendor</code> <code>str | None</code> <p>The vendor of the box. Defaults to None.</p> <code>firmwares</code> <code>FirmwareModel | None</code> <p>The firmware model associated with the box. Defaults to None.</p> Example <p>firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\") box = BoxModel(name=\"Box 1\", serial=\"123456789\", vendor=\"VendorName\", firmwares=firmware) print(box.name) Box 1</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass BoxModel(CamelCaseModel):\n    \"\"\"BoxModel represents a model for a box with various attributes.\n\n    Attributes:\n        name (str | None): The name of the box. Defaults to None.\n        serial (str | None): The serial number of the box. Defaults to None.\n        vendor (str | None): The vendor of the box. Defaults to None.\n        firmwares (FirmwareModel | None): The firmware model associated with the box. Defaults to None.\n\n    Example:\n        &gt;&gt;&gt; firmware = FirmwareModel(box=\"1.0.0\", central=\"2.0.0\", centralradio=\"3.0.0\")\n        &gt;&gt;&gt; box = BoxModel(name=\"Box 1\", serial=\"123456789\", vendor=\"VendorName\", firmwares=firmware)\n        &gt;&gt;&gt; print(box.name)\n        Box 1\n\n    \"\"\"\n\n    name: str | None = None\n    serial: str | None = None\n    vendor: str | None = None\n    firmwares: FirmwareModel | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.AlarmModel","title":"<code>AlarmModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>AlarmModel represents the configuration and state of an alarm system.</p> <p>Attributes:</p> Name Type Description <code>box</code> <code>BoxModel | None</code> <p>The box model associated with the alarm system.</p> <code>plug</code> <code>CentralPlugModel | None</code> <p>The central plug model for the alarm system.</p> <code>tls</code> <code>bool | None</code> <p>Indicates if TLS (Transport Layer Security) is enabled.</p> <code>name</code> <code>str | None</code> <p>The name of the alarm system.</p> <code>central</code> <code>CentralPlugModel | None</code> <p>The central plug model for the alarm system.</p> <code>force_push_config</code> <code>bool | None</code> <p>Indicates if the configuration should be forcefully pushed.                              This attribute is aliased as \"forcePushConfig\".</p> Example <p>box = BoxModel(name=\"Box 1\", serial=\"123456789\", vendor=\"VendorName\") plug = CentralPlugModel(name=\"Central Plug 1\", serial=\"987654321\", vendor=\"VendorName\") alarm = AlarmModel(box=box, plug=plug, tls=True, name=\"Home Alarm\", central=plug, force_push_config=True) print(alarm.name) Home Alarm</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass AlarmModel(CamelCaseModel):\n    \"\"\"AlarmModel represents the configuration and state of an alarm system.\n\n    Attributes:\n        box (BoxModel | None): The box model associated with the alarm system.\n        plug (CentralPlugModel | None): The central plug model for the alarm system.\n        tls (bool | None): Indicates if TLS (Transport Layer Security) is enabled.\n        name (str | None): The name of the alarm system.\n        central (CentralPlugModel | None): The central plug model for the alarm system.\n        force_push_config (bool | None): Indicates if the configuration should be forcefully pushed.\n                                         This attribute is aliased as \"forcePushConfig\".\n\n    Example:\n        &gt;&gt;&gt; box = BoxModel(name=\"Box 1\", serial=\"123456789\", vendor=\"VendorName\")\n        &gt;&gt;&gt; plug = CentralPlugModel(name=\"Central Plug 1\", serial=\"987654321\", vendor=\"VendorName\")\n        &gt;&gt;&gt; alarm = AlarmModel(box=box, plug=plug, tls=True, name=\"Home Alarm\", central=plug, force_push_config=True)\n        &gt;&gt;&gt; print(alarm.name)\n        Home Alarm\n\n    \"\"\"\n\n    box: BoxModel | None = None\n    plug: CentralPlugModel | None = None\n    tls: bool | None = None\n    name: str | None = None\n    central: CentralPlugModel | None = None\n    force_push_config: bool | None = field(\n        default=None, metadata={\"alias\": \"forcePushConfig\"}\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.AlarmConfiguration","title":"<code>AlarmConfiguration</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>AlarmConfiguration model represents the configuration of an alarm system.</p> <p>Attributes:</p> Name Type Description <code>alarm</code> <code>AlarmModel | None</code> <p>The alarm model associated with the configuration.</p> <code>groups</code> <code>list[Group] | None</code> <p>A list of groups associated with the alarm configuration.</p> <code>sirens</code> <code>list[SensorModel] | None</code> <p>A list of siren sensor models.</p> <code>cameras</code> <code>list[Cameras] | None</code> <p>A list of camera models.</p> <code>sensors</code> <code>list[SensorModel] | None</code> <p>A list of sensor models.</p> <code>commands</code> <code>list[SensorModel] | None</code> <p>A list of command sensor models.</p> <code>reading_date</code> <code>datetime | None</code> <p>The date when the configuration was read, aliased as \"readingDate\".</p> <code>transceivers</code> <code>list[TransceiverModel] | None</code> <p>A list of transceiver models.</p> <code>transmitters</code> <code>list[TransmitterModel] | None</code> <p>A list of transmitter models.</p> <code>grp_marche_presence</code> <code>list[int] | None</code> <p>A list of group marche presence, aliased as \"grpMarchePresence\".</p> <code>installation_state</code> <code>int | None</code> <p>The state of the installation, aliased as \"installationState\".</p> <code>central_information</code> <code>CentralInformation | None</code> <p>Information about the central unit, aliased as \"centralInformation\".</p> <code>grp_marche_partielle1</code> <code>list[int] | None</code> <p>A list of group marche partielle 1, aliased as \"grpMarchePartielle1\".</p> <code>grp_marche_partielle2</code> <code>list[int] | None</code> <p>A list of group marche partielle 2, aliased as \"grpMarchePartielle2\".</p> Example <p>alarm_config = AlarmConfiguration( ...     alarm=AlarmModel(name=\"Home Alarm\"), ...     groups=[Group(name=\"Group A\", index=1)], ...     sirens=[SensorModel(uid=\"12345\", type=1)], ...     cameras=[Cameras(uid=\"67890\", type=2)], ...     sensors=[SensorModel(uid=\"54321\", type=3)], ...     commands=[SensorModel(uid=\"98765\", type=4)], ...     reading_date=datetime(2023, 10, 1), ...     transceivers=[TransceiverModel(uid=\"11223\", type=5)], ...     transmitters=[TransmitterModel(uid=\"44556\", type=6)], ...     grp_marche_presence=[1, 2, 3], ...     installation_state=1, ...     central_information=CentralInformation(has_plug=True), ...     grp_marche_partielle1=[4, 5, 6], ...     grp_marche_partielle2=[7, 8, 9] ... ) print(alarm_config.alarm.name) Home Alarm</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass AlarmConfiguration(CamelCaseModel):\n    \"\"\"AlarmConfiguration model represents the configuration of an alarm system.\n\n    Attributes:\n        alarm (AlarmModel | None): The alarm model associated with the configuration.\n        groups (list[Group] | None): A list of groups associated with the alarm configuration.\n        sirens (list[SensorModel] | None): A list of siren sensor models.\n        cameras (list[Cameras] | None): A list of camera models.\n        sensors (list[SensorModel] | None): A list of sensor models.\n        commands (list[SensorModel] | None): A list of command sensor models.\n        reading_date (datetime | None): The date when the configuration was read, aliased as \"readingDate\".\n        transceivers (list[TransceiverModel] | None): A list of transceiver models.\n        transmitters (list[TransmitterModel] | None): A list of transmitter models.\n        grp_marche_presence (list[int] | None): A list of group marche presence, aliased as \"grpMarchePresence\".\n        installation_state (int | None): The state of the installation, aliased as \"installationState\".\n        central_information (CentralInformation | None): Information about the central unit, aliased as \"centralInformation\".\n        grp_marche_partielle1 (list[int] | None): A list of group marche partielle 1, aliased as \"grpMarchePartielle1\".\n        grp_marche_partielle2 (list[int] | None): A list of group marche partielle 2, aliased as \"grpMarchePartielle2\".\n\n    Example:\n        &gt;&gt;&gt; alarm_config = AlarmConfiguration(\n        ...     alarm=AlarmModel(name=\"Home Alarm\"),\n        ...     groups=[Group(name=\"Group A\", index=1)],\n        ...     sirens=[SensorModel(uid=\"12345\", type=1)],\n        ...     cameras=[Cameras(uid=\"67890\", type=2)],\n        ...     sensors=[SensorModel(uid=\"54321\", type=3)],\n        ...     commands=[SensorModel(uid=\"98765\", type=4)],\n        ...     reading_date=datetime(2023, 10, 1),\n        ...     transceivers=[TransceiverModel(uid=\"11223\", type=5)],\n        ...     transmitters=[TransmitterModel(uid=\"44556\", type=6)],\n        ...     grp_marche_presence=[1, 2, 3],\n        ...     installation_state=1,\n        ...     central_information=CentralInformation(has_plug=True),\n        ...     grp_marche_partielle1=[4, 5, 6],\n        ...     grp_marche_partielle2=[7, 8, 9]\n        ... )\n        &gt;&gt;&gt; print(alarm_config.alarm.name)\n        Home Alarm\n\n    \"\"\"\n\n    alarm: AlarmModel | None = None\n    # badges: list[] # Not yet implemented. No enough information in documentation\n    groups: list[Group] | None = None\n    sirens: list[SensorModel] | None = None\n    cameras: list[Cameras] | None = None\n    sensors: list[SensorModel] | None = None\n    commands: list[SensorModel] | None = None\n    reading_date: datetime | None = field(\n        default=None, metadata={\"alias\": \"readingDate\"}\n    )\n    transceivers: list[TransceiverModel] | None = None\n    transmitters: list[TransmitterModel] | None = None\n    grp_marche_presence: list[int] | None = field(\n        default=None, metadata={\"alias\": \"grpMarchePresence\"}\n    )\n    installation_state: int | None = field(\n        default=None, metadata={\"alias\": \"installationState\"}\n    )\n    central_information: CentralInformation | None = field(\n        default=None, metadata={\"alias\": \"centralInformation\"}\n    )\n    grp_marche_partielle1: list[int] | None = field(\n        default=None, metadata={\"alias\": \"grpMarchePartielle1\"}\n    )\n    grp_marche_partielle2: list[int] | None = field(\n        default=None, metadata={\"alias\": \"grpMarchePartielle2\"}\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.DeviceInfos","title":"<code>DeviceInfos</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>DeviceInfos model represents the information of a device.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>The index of the device.</p> <code>label</code> <code>str</code> <p>The label or name of the device.</p> Example <p>device_info = DeviceInfos(index=1, label=\"Sensor 1\") print(device_info.index) 1 print(device_info.label) Sensor 1</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass DeviceInfos(CamelCaseModel):\n    \"\"\"DeviceInfos model represents the information of a device.\n\n    Attributes:\n        index (int): The index of the device.\n        label (str): The label or name of the device.\n\n    Example:\n        &gt;&gt;&gt; device_info = DeviceInfos(index=1, label=\"Sensor 1\")\n        &gt;&gt;&gt; print(device_info.index)\n        1\n        &gt;&gt;&gt; print(device_info.label)\n        Sensor 1\n\n    \"\"\"\n\n    index: int\n    label: str\n</code></pre>"},{"location":"models/#pydiagral.models.DeviceList","title":"<code>DeviceList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>DeviceList model representing a collection of various device types.</p> <p>Attributes:</p> Name Type Description <code>cameras</code> <code>list[DeviceInfos] | None</code> <p>A list of camera devices or None if not available.</p> <code>commands</code> <code>list[DeviceInfos] | None</code> <p>A list of command devices or None if not available.</p> <code>sensors</code> <code>list[DeviceInfos] | None</code> <p>A list of sensor devices or None if not available.</p> <code>sirens</code> <code>list[DeviceInfos] | None</code> <p>A list of siren devices or None if not available.</p> <code>transmitters</code> <code>list[DeviceInfos] | None</code> <p>A list of transmitter devices or None if not available.</p> Example <p>device_list = DeviceList( ...     cameras=[DeviceInfos(index=1, label=\"Camera 1\")], ...     commands=[DeviceInfos(index=2, label=\"Command 1\")], ...     sensors=[DeviceInfos(index=3, label=\"Sensor 1\")], ...     sirens=[DeviceInfos(index=4, label=\"Siren 1\")], ...     transmitters=[DeviceInfos(index=5, label=\"Transmitter 1\")] ... ) print(device_list.cameras[0].label) Camera 1</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass DeviceList(CamelCaseModel):\n    \"\"\"DeviceList model representing a collection of various device types.\n\n    Attributes:\n        cameras (list[DeviceInfos] | None): A list of camera devices or None if not available.\n        commands (list[DeviceInfos] | None): A list of command devices or None if not available.\n        sensors (list[DeviceInfos] | None): A list of sensor devices or None if not available.\n        sirens (list[DeviceInfos] | None): A list of siren devices or None if not available.\n        transmitters (list[DeviceInfos] | None): A list of transmitter devices or None if not available.\n\n    Example:\n        &gt;&gt;&gt; device_list = DeviceList(\n        ...     cameras=[DeviceInfos(index=1, label=\"Camera 1\")],\n        ...     commands=[DeviceInfos(index=2, label=\"Command 1\")],\n        ...     sensors=[DeviceInfos(index=3, label=\"Sensor 1\")],\n        ...     sirens=[DeviceInfos(index=4, label=\"Siren 1\")],\n        ...     transmitters=[DeviceInfos(index=5, label=\"Transmitter 1\")]\n        ... )\n        &gt;&gt;&gt; print(device_list.cameras[0].label)\n        Camera 1\n\n    \"\"\"\n\n    cameras: list[DeviceInfos] | None = None\n    commands: list[DeviceInfos] | None = None\n    sensors: list[DeviceInfos] | None = None\n    sirens: list[DeviceInfos] | None = None\n    transmitters: list[DeviceInfos] | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.SystemDetails","title":"<code>SystemDetails</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>SystemDetails model represents the details of a system with various attributes.</p> <p>Attributes:</p> Name Type Description <code>device_type</code> <code>str</code> <p>The type of the device.</p> <code>firmware_version</code> <code>str</code> <p>The firmware version of the device.</p> <code>ip_address</code> <code>str</code> <p>The IP address of the device.</p> <code>ipoda_version</code> <code>str</code> <p>The version of the IPODA.</p> <code>mode</code> <code>str</code> <p>The mode of the device.</p> <code>first_vocal_contact</code> <code>str</code> <p>The first vocal contact information.</p> <code>is_alarm_file_present</code> <code>bool</code> <p>Indicates if the alarm file is present.</p> <code>is_mjpeg_archive_video_supported</code> <code>str</code> <p>Indicates if MJPEG archive video is supported.</p> <code>is_mass_storage_present</code> <code>str</code> <p>Indicates if mass storage is present.</p> <code>is_remote_startup_shutdown_allowed</code> <code>str</code> <p>Indicates if remote startup/shutdown is allowed.</p> <code>is_video_password_protected</code> <code>str</code> <p>Indicates if the video is password protected.</p> Example <p>system_details = SystemDetails( ...     device_type=\"Camera\", ...     firmware_version=\"1.0.0\", ...     ip_address=\"192.168.1.1\", ...     ipoda_version=\"2.0.0\", ...     mode=\"Active\", ...     first_vocal_contact=\"2023-10-01T12:00:00Z\", ...     is_alarm_file_present=True, ...     is_mjpeg_archive_video_supported=\"Yes\", ...     is_mass_storage_present=\"Yes\", ...     is_remote_startup_shutdown_allowed=\"No\", ...     is_video_password_protected=\"Yes\" ... ) print(system_details.device_type) Camera</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass SystemDetails(CamelCaseModel):\n    \"\"\"SystemDetails model represents the details of a system with various attributes.\n\n    Attributes:\n        device_type (str): The type of the device.\n        firmware_version (str): The firmware version of the device.\n        ip_address (str): The IP address of the device.\n        ipoda_version (str): The version of the IPODA.\n        mode (str): The mode of the device.\n        first_vocal_contact (str): The first vocal contact information.\n        is_alarm_file_present (bool): Indicates if the alarm file is present.\n        is_mjpeg_archive_video_supported (str): Indicates if MJPEG archive video is supported.\n        is_mass_storage_present (str): Indicates if mass storage is present.\n        is_remote_startup_shutdown_allowed (str): Indicates if remote startup/shutdown is allowed.\n        is_video_password_protected (str): Indicates if the video is password protected.\n\n    Example:\n        &gt;&gt;&gt; system_details = SystemDetails(\n        ...     device_type=\"Camera\",\n        ...     firmware_version=\"1.0.0\",\n        ...     ip_address=\"192.168.1.1\",\n        ...     ipoda_version=\"2.0.0\",\n        ...     mode=\"Active\",\n        ...     first_vocal_contact=\"2023-10-01T12:00:00Z\",\n        ...     is_alarm_file_present=True,\n        ...     is_mjpeg_archive_video_supported=\"Yes\",\n        ...     is_mass_storage_present=\"Yes\",\n        ...     is_remote_startup_shutdown_allowed=\"No\",\n        ...     is_video_password_protected=\"Yes\"\n        ... )\n        &gt;&gt;&gt; print(system_details.device_type)\n        Camera\n\n    \"\"\"\n\n    device_type: str = field(metadata={\"alias\": \"DeviceType\"})\n    firmware_version: str = field(metadata={\"alias\": \"FirmwareVersion\"})\n    ip_address: str = field(metadata={\"alias\": \"IpAddress\"})\n    ipoda_version: str = field(metadata={\"alias\": \"IpodaVersion\"})\n    mode: str = field(metadata={\"alias\": \"Mode\"})\n    first_vocal_contact: str = field(metadata={\"alias\": \"FirstVocalContact\"})\n    is_alarm_file_present: bool = field(metadata={\"alias\": \"IsAlarmFilePresent\"})\n    is_mjpeg_archive_video_supported: str = field(\n        metadata={\"alias\": \"IsMJPEGArchiveVideoSupported\"}\n    )\n    is_mass_storage_present: str = field(metadata={\"alias\": \"IsMassStoragePresent\"})\n    is_remote_startup_shutdown_allowed: str = field(\n        metadata={\"alias\": \"IsRemoteStartupShutdownAllowed\"}\n    )\n    is_video_password_protected: str = field(\n        metadata={\"alias\": \"IsVideoPasswordProtected\"}\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.SystemStatus","title":"<code>SystemStatus</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>SystemStatus represents the status of a system with various attributes.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str</code> <p>The current status of the system.</p> <code>activated_groups</code> <code>list[int]</code> <p>A list of IDs representing the activated groups within the system.</p> Example <p>system_status = SystemStatus(status=\"Active\", activated_groups=[1, 2, 3]) print(system_status.status) Active print(system_status.activated_groups) [1, 2, 3]</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass SystemStatus(CamelCaseModel):\n    \"\"\"SystemStatus represents the status of a system with various attributes.\n\n    Attributes:\n        status (str): The current status of the system.\n        activated_groups (list[int]): A list of IDs representing the activated groups within the system.\n\n    Example:\n        &gt;&gt;&gt; system_status = SystemStatus(status=\"Active\", activated_groups=[1, 2, 3])\n        &gt;&gt;&gt; print(system_status.status)\n        Active\n        &gt;&gt;&gt; print(system_status.activated_groups)\n        [1, 2, 3]\n\n    \"\"\"\n\n    status: str\n    activated_groups: list[int]\n</code></pre>"},{"location":"models/#pydiagral.models.AnomalyName","title":"<code>AnomalyName</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>AnomalyName model representing an anomaly with an identifier and a name.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for the anomaly.</p> <code>name</code> <code>str</code> <p>The name of the anomaly.</p> Example <p>anomaly = AnomalyName(id=1, name=\"Low Battery\") print(anomaly.id) 1 print(anomaly.name) Low Battery</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass AnomalyName(CamelCaseModel):\n    \"\"\"AnomalyName model representing an anomaly with an identifier and a name.\n\n    Attributes:\n        id (int): The unique identifier for the anomaly.\n        name (str): The name of the anomaly.\n\n    Example:\n        &gt;&gt;&gt; anomaly = AnomalyName(id=1, name=\"Low Battery\")\n        &gt;&gt;&gt; print(anomaly.id)\n        1\n        &gt;&gt;&gt; print(anomaly.name)\n        Low Battery\n\n    \"\"\"\n\n    id: int\n    name: str\n</code></pre>"},{"location":"models/#pydiagral.models.AnomalyDetail","title":"<code>AnomalyDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>AnomalyDetail represents detailed information about an anomaly.</p> <p>Attributes:</p> Name Type Description <code>anomaly_names</code> <code>list[AnomalyName]</code> <p>A list of anomaly names associated with this detail.</p> <code>serial</code> <code>str | None</code> <p>An optional serial number associated with the anomaly.</p> <code>index</code> <code>int | None</code> <p>An optional index value for the anomaly.</p> <code>group</code> <code>int | None</code> <p>An optional group identifier for the anomaly.</p> <code>label</code> <code>str | None</code> <p>An optional label describing the anomaly.</p> Example <p>anomaly_names = [AnomalyName(id=1, name=\"Low Battery\")] anomaly_detail = AnomalyDetail( ...     anomaly_names=anomaly_names, ...     serial=\"SN12345\", ...     index=1, ...     group=2, ...     label=\"Sensor Anomaly\" ... ) print(anomaly_detail.serial) SN12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass AnomalyDetail(CamelCaseModel):\n    \"\"\"AnomalyDetail represents detailed information about an anomaly.\n\n    Attributes:\n        anomaly_names (list[AnomalyName]): A list of anomaly names associated with this detail.\n        serial (str | None): An optional serial number associated with the anomaly.\n        index (int | None): An optional index value for the anomaly.\n        group (int | None): An optional group identifier for the anomaly.\n        label (str | None): An optional label describing the anomaly.\n\n    Example:\n        &gt;&gt;&gt; anomaly_names = [AnomalyName(id=1, name=\"Low Battery\")]\n        &gt;&gt;&gt; anomaly_detail = AnomalyDetail(\n        ...     anomaly_names=anomaly_names,\n        ...     serial=\"SN12345\",\n        ...     index=1,\n        ...     group=2,\n        ...     label=\"Sensor Anomaly\"\n        ... )\n        &gt;&gt;&gt; print(anomaly_detail.serial)\n        SN12345\n\n    \"\"\"\n\n    anomaly_names: list[AnomalyName]\n    serial: str | None = None\n    index: int | None = None\n    group: int | None = None\n    label: str | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.Anomalies","title":"<code>Anomalies</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>A model representing anomalies detected in various devices.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>datetime</code> <p>The timestamp when the anomalies were created.</p> <code>sensors</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for sensors, or None if no anomalies.</p> <code>badges</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for badges, or None if no anomalies.</p> <code>sirens</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for sirens, or None if no anomalies.</p> <code>cameras</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for cameras, or None if no anomalies.</p> <code>commands</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for commands, or None if no anomalies.</p> <code>transceivers</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for transceivers, or None if no anomalies.</p> <code>transmitters</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for transmitters, or None if no anomalies.</p> <code>central</code> <code>list[AnomalyDetail] | None</code> <p>A list of anomaly details for central devices, or None if no anomalies.</p> <p>Methods:</p> Name Description <code>from_dict</code> <p>dict) -&gt; Anomalies: Create an instance of Anomalies from a dictionary.</p> Example <p>data = { ...     \"created_at\": \"2025-02-16T10:15:12.625165\", ...     \"sensors\": [ ...         { ...             \"serial\": \"SN12345\", ...             \"index\": 1, ...             \"group\": 2, ...             \"label\": \"Sensor Anomaly\", ...             \"anomaly_names\": [{\"id\": 1, \"name\": \"Low Battery\"}] ...         } ...     ] ... } anomalies = Anomalies.from_dict(data) print(anomalies.created_at) 2025-02-16 10:15:12.625165+00:00 print(anomalies.sensors[0].serial) SN12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass Anomalies(CamelCaseModel):\n    \"\"\"A model representing anomalies detected in various devices.\n\n    Attributes:\n        created_at (datetime): The timestamp when the anomalies were created.\n        sensors (list[AnomalyDetail] | None): A list of anomaly details for sensors, or None if no anomalies.\n        badges (list[AnomalyDetail] | None): A list of anomaly details for badges, or None if no anomalies.\n        sirens (list[AnomalyDetail] | None): A list of anomaly details for sirens, or None if no anomalies.\n        cameras (list[AnomalyDetail] | None): A list of anomaly details for cameras, or None if no anomalies.\n        commands (list[AnomalyDetail] | None): A list of anomaly details for commands, or None if no anomalies.\n        transceivers (list[AnomalyDetail] | None): A list of anomaly details for transceivers, or None if no anomalies.\n        transmitters (list[AnomalyDetail] | None): A list of anomaly details for transmitters, or None if no anomalies.\n        central (list[AnomalyDetail] | None): A list of anomaly details for central devices, or None if no anomalies.\n\n    Methods:\n        from_dict(data: dict) -&gt; Anomalies:\n            Create an instance of Anomalies from a dictionary.\n\n    Example:\n        &gt;&gt;&gt; data = {\n        ...     \"created_at\": \"2025-02-16T10:15:12.625165\",\n        ...     \"sensors\": [\n        ...         {\n        ...             \"serial\": \"SN12345\",\n        ...             \"index\": 1,\n        ...             \"group\": 2,\n        ...             \"label\": \"Sensor Anomaly\",\n        ...             \"anomaly_names\": [{\"id\": 1, \"name\": \"Low Battery\"}]\n        ...         }\n        ...     ]\n        ... }\n        &gt;&gt;&gt; anomalies = Anomalies.from_dict(data)\n        &gt;&gt;&gt; print(anomalies.created_at)\n        2025-02-16 10:15:12.625165+00:00\n        &gt;&gt;&gt; print(anomalies.sensors[0].serial)\n        SN12345\n\n    \"\"\"\n\n    created_at: datetime\n    sensors: list[AnomalyDetail] | None = None\n    badges: list[AnomalyDetail] | None = None\n    sirens: list[AnomalyDetail] | None = None\n    cameras: list[AnomalyDetail] | None = None\n    commands: list[AnomalyDetail] | None = None\n    transceivers: list[AnomalyDetail] | None = None\n    transmitters: list[AnomalyDetail] | None = None\n    central: list[AnomalyDetail] | None = None\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; Anomalies:\n        \"\"\"Create an instance of Anomalies from a dictionary.\"\"\"\n\n        def create_devices(device_data):\n            return [\n                AnomalyDetail(\n                    serial=data.get(\"serial\"),\n                    index=data.get(\"index\"),\n                    group=data.get(\"group\"),\n                    label=data.get(\"label\"),\n                    anomaly_names=[AnomalyName(**a) for a in data.get(\"anomaly_names\")],\n                )\n                for data in device_data\n            ]\n\n        # Convert the created_at field to a datetime object with UTC timezone\n        created_at = datetime.fromisoformat(data[\"created_at\"]).replace(\n            tzinfo=timezone.utc\n        )\n\n        return cls(\n            created_at=created_at,\n            sensors=create_devices(data.get(\"sensors\", [])),\n            badges=create_devices(data.get(\"badges\", [])),\n            sirens=create_devices(data.get(\"sirens\", [])),\n            cameras=create_devices(data.get(\"cameras\", [])),\n            commands=create_devices(data.get(\"commands\", [])),\n            transceivers=create_devices(data.get(\"transceivers\", [])),\n            transmitters=create_devices(data.get(\"transmitters\", [])),\n            central=create_devices(data.get(\"central\", [])),\n        )\n</code></pre>"},{"location":"models/#pydiagral.models.Anomalies.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of Anomalies from a dictionary.</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; Anomalies:\n    \"\"\"Create an instance of Anomalies from a dictionary.\"\"\"\n\n    def create_devices(device_data):\n        return [\n            AnomalyDetail(\n                serial=data.get(\"serial\"),\n                index=data.get(\"index\"),\n                group=data.get(\"group\"),\n                label=data.get(\"label\"),\n                anomaly_names=[AnomalyName(**a) for a in data.get(\"anomaly_names\")],\n            )\n            for data in device_data\n        ]\n\n    # Convert the created_at field to a datetime object with UTC timezone\n    created_at = datetime.fromisoformat(data[\"created_at\"]).replace(\n        tzinfo=timezone.utc\n    )\n\n    return cls(\n        created_at=created_at,\n        sensors=create_devices(data.get(\"sensors\", [])),\n        badges=create_devices(data.get(\"badges\", [])),\n        sirens=create_devices(data.get(\"sirens\", [])),\n        cameras=create_devices(data.get(\"cameras\", [])),\n        commands=create_devices(data.get(\"commands\", [])),\n        transceivers=create_devices(data.get(\"transceivers\", [])),\n        transmitters=create_devices(data.get(\"transmitters\", [])),\n        central=create_devices(data.get(\"central\", [])),\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.WebhookSubscription","title":"<code>WebhookSubscription</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>Represents a subscription to webhook notifications.</p> <p>Attributes:</p> Name Type Description <code>anomaly</code> <code>bool</code> <p>Indicates whether anomaly notifications are enabled.</p> <code>alert</code> <code>bool</code> <p>Indicates whether alert notifications are enabled.</p> <code>state</code> <code>bool</code> <p>Indicates whether state notifications are enabled.</p> Example <p>subscription = WebhookSubscription(anomaly=True, alert=False, state=True) print(subscription.anomaly) True</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass WebhookSubscription(CamelCaseModel):\n    \"\"\"Represents a subscription to webhook notifications.\n\n    Attributes:\n        anomaly (bool): Indicates whether anomaly notifications are enabled.\n        alert (bool): Indicates whether alert notifications are enabled.\n        state (bool): Indicates whether state notifications are enabled.\n\n    Example:\n        &gt;&gt;&gt; subscription = WebhookSubscription(anomaly=True, alert=False, state=True)\n        &gt;&gt;&gt; print(subscription.anomaly)\n        True\n\n    \"\"\"\n\n    anomaly: bool\n    alert: bool\n    state: bool\n</code></pre>"},{"location":"models/#pydiagral.models.Webhook","title":"<code>Webhook</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>Represents a Webhook model.</p> <p>Attributes:</p> Name Type Description <code>transmitter_id</code> <code>str</code> <p>The unique identifier for the transmitter.</p> <code>webhook_url</code> <code>str</code> <p>The URL to which the webhook will send data.</p> <code>subscriptions</code> <code>WebhookSubscription</code> <p>The subscription details for the webhook.</p> Example <p>subscription = WebhookSubscription(anomaly=True, alert=False, state=True) webhook = Webhook(transmitter_id=\"12345\", webhook_url=\"https://example.com/webhook\", subscriptions=subscription) print(webhook.transmitter_id) 12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass Webhook(CamelCaseModel):\n    \"\"\"Represents a Webhook model.\n\n    Attributes:\n        transmitter_id (str): The unique identifier for the transmitter.\n        webhook_url (str): The URL to which the webhook will send data.\n        subscriptions (WebhookSubscription): The subscription details for the webhook.\n\n    Example:\n        &gt;&gt;&gt; subscription = WebhookSubscription(anomaly=True, alert=False, state=True)\n        &gt;&gt;&gt; webhook = Webhook(transmitter_id=\"12345\", webhook_url=\"https://example.com/webhook\", subscriptions=subscription)\n        &gt;&gt;&gt; print(webhook.transmitter_id)\n        12345\n\n    \"\"\"\n\n    transmitter_id: str\n    webhook_url: str\n    subscriptions: WebhookSubscription\n</code></pre>"},{"location":"models/#pydiagral.models.WebHookNotificationDetail","title":"<code>WebHookNotificationDetail</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>WebHookNotificationDetail model represents the details of a webhook notification.</p> <p>Attributes:</p> Name Type Description <code>device_type</code> <code>str</code> <p>The type of the device.</p> <code>device_index</code> <code>str</code> <p>The index of the device.</p> <code>device_label</code> <code>str | None</code> <p>The label of the device, which is optional.</p> Example <p>detail = WebHookNotificationDetail(device_type=\"Sensor\", device_index=\"1\", device_label=\"Front Door Sensor\") print(detail.device_type) Sensor print(detail.device_index) 1 print(detail.device_label) Front Door Sensor</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass WebHookNotificationDetail(CamelCaseModel):\n    \"\"\"WebHookNotificationDetail model represents the details of a webhook notification.\n\n    Attributes:\n        device_type (str): The type of the device.\n        device_index (str): The index of the device.\n        device_label (str | None): The label of the device, which is optional.\n\n    Example:\n        &gt;&gt;&gt; detail = WebHookNotificationDetail(device_type=\"Sensor\", device_index=\"1\", device_label=\"Front Door Sensor\")\n        &gt;&gt;&gt; print(detail.device_type)\n        Sensor\n        &gt;&gt;&gt; print(detail.device_index)\n        1\n        &gt;&gt;&gt; print(detail.device_label)\n        Front Door Sensor\n\n    \"\"\"\n\n    device_type: str\n    device_index: str\n    device_label: str | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.WebHookNotificationUser","title":"<code>WebHookNotificationUser</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>WebHookNotificationUser represents a user who receives webhook notifications.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The username of the user.</p> <code>user_type</code> <code>str</code> <p>The type of the user.</p> Example <p>user = WebHookNotificationUser(username=\"Dark Vador\", user_type=\"owner\") print(user.username) Dark Vador print(detail.user_type) owner</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass WebHookNotificationUser(CamelCaseModel):\n    \"\"\"WebHookNotificationUser represents a user who receives webhook notifications.\n\n    Attributes:\n        username (str): The username of the user.\n        user_type (str): The type of the user.\n\n    Example:\n        &gt;&gt;&gt; user = WebHookNotificationUser(username=\"Dark Vador\", user_type=\"owner\")\n        &gt;&gt;&gt; print(user.username)\n        Dark Vador\n        &gt;&gt;&gt; print(detail.user_type)\n        owner\n\n    \"\"\"\n\n    username: str\n    user_type: str\n</code></pre>"},{"location":"models/#pydiagral.models.WebHookNotification","title":"<code>WebHookNotification</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>A model representing a webhook notification.</p> <p>Attributes:</p> Name Type Description <code>transmitter_id</code> <code>str</code> <p>The ID of the transmitter sending the notification.</p> <code>alarm_type</code> <code>str</code> <p>The type of alarm, determined based on the alarm code.</p> <code>alarm_code</code> <code>str</code> <p>The code representing the specific alarm.</p> <code>alarm_description</code> <code>str</code> <p>A description of the alarm.</p> <code>group_index</code> <code>str</code> <p>The index of the group associated with the alarm.</p> <code>detail</code> <code>WebHookNotificationDetail</code> <p>Detailed information about the webhook notification. Only during anomaly/alert notification.</p> <code>user</code> <code>WebHookNotificationUser</code> <p>The user who trigger the notification. Only during change state notification.</p> <code>date_time</code> <code>datetime</code> <p>The date and time when the notification was generated.</p> <p>Methods:</p> Name Description <code>from_dict</code> <p>dict) -&gt; WebHookNotification: Create an instance of WebHookNotification from a dictionary.</p> Example <p>data = { ...     \"transmitter_id\": \"12345\", ...     \"alarm_code\": \"1130\", ...     \"alarm_description\": \"Intrusion detected\", ...     \"group_index\": \"01\", ...     \"detail\": { ...         \"device_type\": \"Sensor\", ...         \"device_index\": \"1\", ...         \"device_label\": \"Front Door Sensor\" ...     }, ...     \"date_time\": \"2023-10-01T12:00:00Z\" ... } notification = WebHookNotification.from_dict(data) print(notification.transmitter_id) 12345</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass WebHookNotification(CamelCaseModel):\n    \"\"\"A model representing a webhook notification.\n\n    Attributes:\n        transmitter_id (str): The ID of the transmitter sending the notification.\n        alarm_type (str): The type of alarm, determined based on the alarm code.\n        alarm_code (str): The code representing the specific alarm.\n        alarm_description (str): A description of the alarm.\n        group_index (str): The index of the group associated with the alarm.\n        detail (WebHookNotificationDetail): Detailed information about the webhook notification.\n            Only during anomaly/alert notification.\n        user (WebHookNotificationUser): The user who trigger the notification.\n            Only during change state notification.\n        date_time (datetime): The date and time when the notification was generated.\n\n    Methods:\n        from_dict(data: dict) -&gt; WebHookNotification:\n            Create an instance of WebHookNotification from a dictionary.\n\n    Example:\n        &gt;&gt;&gt; data = {\n        ...     \"transmitter_id\": \"12345\",\n        ...     \"alarm_code\": \"1130\",\n        ...     \"alarm_description\": \"Intrusion detected\",\n        ...     \"group_index\": \"01\",\n        ...     \"detail\": {\n        ...         \"device_type\": \"Sensor\",\n        ...         \"device_index\": \"1\",\n        ...         \"device_label\": \"Front Door Sensor\"\n        ...     },\n        ...     \"date_time\": \"2023-10-01T12:00:00Z\"\n        ... }\n        &gt;&gt;&gt; notification = WebHookNotification.from_dict(data)\n        &gt;&gt;&gt; print(notification.transmitter_id)\n        12345\n\n    \"\"\"\n\n    transmitter_id: str\n    alarm_type: str  # Not included in Diagral answer. Added with below function\n    alarm_code: str\n    alarm_description: str\n    group_index: str\n    detail: WebHookNotificationDetail\n    user: WebHookNotificationUser\n    date_time: datetime\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; WebHookNotification:\n        \"\"\"Create an instance of WebHookNotification from a dictionary.\"\"\"\n\n        def alarm_type(alarm_code):\n            \"\"\"Determine the type of alarm based on the alarm code.\"\"\"\n            ANOMALY_CODES = [\n                1301,\n                3301,\n                1137,\n                3137,\n                1355,\n                3355,\n                1381,\n                3381,\n                1144,\n                3144,\n                1302,\n                1384,\n                1570,\n                3570,\n                1352,\n                3352,\n                1351,\n                3351,\n                1573,\n            ]\n            ALERT_CODES = [\n                1130,\n                1110,\n                1111,\n                1117,\n                1158,\n                1139,\n                1344,\n                1120,\n                1122,\n                1159,\n                1152,\n                1154,\n                1150,\n                1140,\n                1141,\n                1142,\n                1143,\n                3391,\n                1391,\n            ]\n            STATUS_CODES = [1306, 3401, 3407, 1401, 1407]\n\n            if int(alarm_code) in ANOMALY_CODES:\n                return \"ANOMALY\"\n            if int(alarm_code) in ALERT_CODES:\n                return \"ALERT\"\n            if int(alarm_code) in STATUS_CODES:\n                return \"STATUS\"\n            return \"UNKNOWN\"\n\n        return cls(\n            transmitter_id=data.get(\"transmitter_id\"),\n            alarm_type=alarm_type(data.get(\"alarm_code\")),\n            alarm_code=data.get(\"alarm_code\"),\n            alarm_description=data.get(\"alarm_description\"),\n            group_index=data.get(\"group_index\"),\n            detail=WebHookNotificationDetail(\n                device_type=data.get(\"detail\", {}).get(\"device_type\", None),\n                device_index=data.get(\"detail\", {}).get(\"device_index\", None),\n                device_label=data.get(\"detail\", {}).get(\"device_label\", None),\n            ),\n            user=WebHookNotificationUser(\n                username=data.get(\"user\", {}).get(\"username\", None),\n                user_type=data.get(\"user\", {}).get(\"user_type\", None),\n            ),\n            date_time=datetime.fromisoformat(data[\"date_time\"].replace(\"Z\", \"+00:00\")),\n        )\n</code></pre>"},{"location":"models/#pydiagral.models.WebHookNotification.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create an instance of WebHookNotification from a dictionary.</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; WebHookNotification:\n    \"\"\"Create an instance of WebHookNotification from a dictionary.\"\"\"\n\n    def alarm_type(alarm_code):\n        \"\"\"Determine the type of alarm based on the alarm code.\"\"\"\n        ANOMALY_CODES = [\n            1301,\n            3301,\n            1137,\n            3137,\n            1355,\n            3355,\n            1381,\n            3381,\n            1144,\n            3144,\n            1302,\n            1384,\n            1570,\n            3570,\n            1352,\n            3352,\n            1351,\n            3351,\n            1573,\n        ]\n        ALERT_CODES = [\n            1130,\n            1110,\n            1111,\n            1117,\n            1158,\n            1139,\n            1344,\n            1120,\n            1122,\n            1159,\n            1152,\n            1154,\n            1150,\n            1140,\n            1141,\n            1142,\n            1143,\n            3391,\n            1391,\n        ]\n        STATUS_CODES = [1306, 3401, 3407, 1401, 1407]\n\n        if int(alarm_code) in ANOMALY_CODES:\n            return \"ANOMALY\"\n        if int(alarm_code) in ALERT_CODES:\n            return \"ALERT\"\n        if int(alarm_code) in STATUS_CODES:\n            return \"STATUS\"\n        return \"UNKNOWN\"\n\n    return cls(\n        transmitter_id=data.get(\"transmitter_id\"),\n        alarm_type=alarm_type(data.get(\"alarm_code\")),\n        alarm_code=data.get(\"alarm_code\"),\n        alarm_description=data.get(\"alarm_description\"),\n        group_index=data.get(\"group_index\"),\n        detail=WebHookNotificationDetail(\n            device_type=data.get(\"detail\", {}).get(\"device_type\", None),\n            device_index=data.get(\"detail\", {}).get(\"device_index\", None),\n            device_label=data.get(\"detail\", {}).get(\"device_label\", None),\n        ),\n        user=WebHookNotificationUser(\n            username=data.get(\"user\", {}).get(\"username\", None),\n            user_type=data.get(\"user\", {}).get(\"user_type\", None),\n        ),\n        date_time=datetime.fromisoformat(data[\"date_time\"].replace(\"Z\", \"+00:00\")),\n    )\n</code></pre>"},{"location":"models/#pydiagral.models.Rude","title":"<code>Rude</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>Rude model representing a device with a name, canal, and mode.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the device.</p> <code>canal</code> <code>str</code> <p>The canal associated with the device.</p> <code>mode</code> <code>str</code> <p>The mode of operation for the device. Must be one of {\"ON\", \"PULSE\", \"SWITCH\", \"TIMER\"}.</p> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Post-initialization processing to validate the mode attribute.</p> Example <p>rude = Rude(name=\"Device1\", canal=\"Canal1\", mode=\"ON\") print(rude.name) Device1</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass Rude(CamelCaseModel):\n    \"\"\"Rude model representing a device with a name, canal, and mode.\n\n    Attributes:\n        name (str): The name of the device.\n        canal (str): The canal associated with the device.\n        mode (str): The mode of operation for the device. Must be one of {\"ON\", \"PULSE\", \"SWITCH\", \"TIMER\"}.\n\n    Methods:\n        __post_init__(): Post-initialization processing to validate the mode attribute.\n\n    Example:\n        &gt;&gt;&gt; rude = Rude(name=\"Device1\", canal=\"Canal1\", mode=\"ON\")\n        &gt;&gt;&gt; print(rude.name)\n        Device1\n\n    \"\"\"\n\n    name: str\n    canal: str\n    mode: str\n\n    def __post_init__(self):\n        \"\"\"Post-initialization processing to validate mode.\"\"\"\n        valid_modes = {\"ON\", \"PULSE\", \"SWITCH\", \"TIMER\"}\n        if self.mode not in valid_modes:\n            raise ValueError(f\"mode must be one of {valid_modes}\")\n</code></pre>"},{"location":"models/#pydiagral.models.Rude.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization processing to validate mode.</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Post-initialization processing to validate mode.\"\"\"\n    valid_modes = {\"ON\", \"PULSE\", \"SWITCH\", \"TIMER\"}\n    if self.mode not in valid_modes:\n        raise ValueError(f\"mode must be one of {valid_modes}\")\n</code></pre>"},{"location":"models/#pydiagral.models.Rudes","title":"<code>Rudes</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>Rudes model representing a collection of Rude instances.</p> <p>Attributes:</p> Name Type Description <code>rudes</code> <code>list[Rude]</code> <p>A list of Rude objects.</p> Example <p>rude1 = Rude(name=\"Device1\", canal=\"Canal1\", mode=\"ON\") rude2 = Rude(name=\"Device2\", canal=\"Canal2\", mode=\"PULSE\") rudes = Rudes(rudes=[rude1, rude2]) print(rudes.rudes[0].name) Device1</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass Rudes(CamelCaseModel):\n    \"\"\"Rudes model representing a collection of Rude instances.\n\n    Attributes:\n        rudes (list[Rude]): A list of Rude objects.\n\n    Example:\n        &gt;&gt;&gt; rude1 = Rude(name=\"Device1\", canal=\"Canal1\", mode=\"ON\")\n        &gt;&gt;&gt; rude2 = Rude(name=\"Device2\", canal=\"Canal2\", mode=\"PULSE\")\n        &gt;&gt;&gt; rudes = Rudes(rudes=[rude1, rude2])\n        &gt;&gt;&gt; print(rudes.rudes[0].name)\n        Device1\n\n    \"\"\"\n\n    rudes: list[Rude]\n</code></pre>"},{"location":"models/#pydiagral.models.ValidationError","title":"<code>ValidationError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>ValidationError model represents an error that occurs during validation.</p> <p>Attributes:</p> Name Type Description <code>loc</code> <code>list[str] | None</code> <p>The location of the error, typically indicating the field or attribute that caused the error.</p> <code>message</code> <code>str | None</code> <p>A human-readable message describing the error.</p> <code>type</code> <code>str | None</code> <p>The type or category of the error.</p> <code>input</code> <code>str | None</code> <p>The input value that caused the error.</p> <code>url</code> <code>str | None</code> <p>A URL providing more information about the error.</p> Example <p>error = ValidationError( ...     loc=[\"body\", \"username\"], ...     message=\"Username is required\", ...     type=\"value_error.missing\", ...     input=None, ...     url=\"https://example.com/errors/username-required\" ... ) print(error.message) Username is required</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass ValidationError(CamelCaseModel):\n    \"\"\"ValidationError model represents an error that occurs during validation.\n\n    Attributes:\n        loc (list[str] | None): The location of the error, typically indicating the field or attribute that caused the error.\n        message (str | None): A human-readable message describing the error.\n        type (str | None): The type or category of the error.\n        input (str | None): The input value that caused the error.\n        url (str | None): A URL providing more information about the error.\n\n    Example:\n        &gt;&gt;&gt; error = ValidationError(\n        ...     loc=[\"body\", \"username\"],\n        ...     message=\"Username is required\",\n        ...     type=\"value_error.missing\",\n        ...     input=None,\n        ...     url=\"https://example.com/errors/username-required\"\n        ... )\n        &gt;&gt;&gt; print(error.message)\n        Username is required\n\n    \"\"\"\n\n    loc: list[str] | None = None\n    message: str | None = None\n    type: str | None = None\n    input: str | None = None\n    url: str | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.HTTPValidationError","title":"<code>HTTPValidationError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ValidationError</code></p> <p>HTTPValidationError is a subclass of ValidationError that represents an HTTP validation error.</p> <p>Attributes:</p> Name Type Description <code>detail</code> <code>list[ValidationError] | None</code> <p>A list of ValidationError instances or None, providing detailed information about the validation errors.</p> Example <p>error_detail = ValidationError( ...     loc=[\"body\", \"username\"], ...     message=\"Username is required\", ...     type=\"value_error.missing\", ...     input=None, ...     url=\"https://example.com/errors/username-required\" ... ) http_error = HTTPValidationError(detail=[error_detail]) print(http_error.detail[0].message) Username is required</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass HTTPValidationError(ValidationError):\n    \"\"\"HTTPValidationError is a subclass of ValidationError that represents an HTTP validation error.\n\n    Attributes:\n        detail (list[ValidationError] | None): A list of ValidationError instances or None, providing detailed information about the validation errors.\n\n    Example:\n        &gt;&gt;&gt; error_detail = ValidationError(\n        ...     loc=[\"body\", \"username\"],\n        ...     message=\"Username is required\",\n        ...     type=\"value_error.missing\",\n        ...     input=None,\n        ...     url=\"https://example.com/errors/username-required\"\n        ... )\n        &gt;&gt;&gt; http_error = HTTPValidationError(detail=[error_detail])\n        &gt;&gt;&gt; print(http_error.detail[0].message)\n        Username is required\n\n    \"\"\"\n\n    detail: list[ValidationError] | None = None\n</code></pre>"},{"location":"models/#pydiagral.models.HTTPErrorResponse","title":"<code>HTTPErrorResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CamelCaseModel</code></p> <p>HTTPErrorResponse is a model that represents an HTTP error response.</p> <p>Attributes:</p> Name Type Description <code>detail</code> <code>str</code> <p>A detailed message describing the error.</p> Example <p>error_response = HTTPErrorResponse(detail=\"Not Found\") print(error_response.detail) Not Found</p> Source code in <code>src/pydiagral/models.py</code> <pre><code>@dataclass\nclass HTTPErrorResponse(CamelCaseModel):\n    \"\"\"HTTPErrorResponse is a model that represents an HTTP error response.\n\n    Attributes:\n        detail (str): A detailed message describing the error.\n\n    Example:\n        &gt;&gt;&gt; error_response = HTTPErrorResponse(detail=\"Not Found\")\n        &gt;&gt;&gt; print(error_response.detail)\n        Not Found\n\n    \"\"\"\n\n    detail: str\n</code></pre>"}]}